{"meta":{"title":"Scofieldyu","subtitle":"高筑墙-广积粮-缓称王","description":"Do it anywany.That's dream actually!","author":"俞 元","url":"http://Scofieldsu.github.io"},"pages":[{"title":"","date":"2016-07-07T14:29:32.000Z","updated":"2018-03-20T19:10:56.678Z","comments":true,"path":"about/index.html","permalink":"http://Scofieldsu.github.io/about/index.html","excerpt":"","text":"喜欢折腾。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&#123; name: 'Scofieldyu' borth: 1994-1, gender: '男', profession: 'Engineer', address: '厦门', education: '本科（2011/09–2015/06 集美大学 软件工程专业）', github: 'https://github.com/Scofieldsu', blog: 'http://Scofieldsu.github,io', email: 'yuyuan_v@163.com', interest: ['篮球',‘电影’, '阅读'] description: '', mark: ' - python - vue - java - odoo - shell - docker - git - js - wifi-ios-mac-analyize-reserach - heatmap - gitlab-oauth - shadowsocks - nodejs - react - go ----to do or keep - 概率论-线性代数-数值统计-微积分 ==》 机器学习，深度学习 - Practice spoken English - 区块链 - 保持阅读和观影'&#125;"},{"title":"Hello World","date":"2018-01-14T09:54:05.167Z","updated":"2018-01-13T20:49:36.248Z","comments":true,"path":"write/hello-world.html","permalink":"http://Scofieldsu.github.io/write/hello-world.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment"}],"posts":[{"title":"如果","slug":"如果","date":"2017-06-15T15:20:26.000Z","updated":"2018-01-14T18:02:40.531Z","comments":true,"path":"2017/06/15/如果/","link":"","permalink":"http://Scofieldsu.github.io/2017/06/15/如果/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051如 果[英]吉 卜林如果 在 众人 六神无主 时你 能 镇定自若 而不是 人云亦云如果 在 被众人 猜忌怀疑 之日你 能 自信如常 而不去 枉加辩论如果 你有梦想 又 不迷失自我如果 你有神思 又 不致走火入魔如果 在成功之中 能 不妄形于色而在 灾难之后 也勇于 咀嚼苦果如果 听到自己说出的奥秘 被无赖歪曲成面目全非的魔术而不生怨艾如果 看到自己追求的美好 受天灾破灭为 零碎的瓦砾 也不说放弃如果 你辛苦劳作 已是功成名就还是 冒险一博 哪怕功名成乌有即使 惨遭失败 也仍要从头开始如果 你跟村夫交谈 而不失恭敬之态和王侯散步 而不露谀媚之颜如果 他人的爱憎 左右不了你的正气如果 你和任何人为伍 都能卓然独立如果 昏惑的骚扰 动摇不了你的意志你能 等自己平心静气再作答谢那么 你的修养 就如同天地般博大你 就是 真正的男子汉了我 的 儿 子","categories":[{"name":"诗和小说以及文章","slug":"诗和小说以及文章","permalink":"http://Scofieldsu.github.io/categories/诗和小说以及文章/"}],"tags":[{"name":"The_Life_You_Want","slug":"The-Life-You-Want","permalink":"http://Scofieldsu.github.io/tags/The-Life-You-Want/"}]},{"title":"vue.js入门","slug":"vuejs入门","date":"2017-06-01T14:39:08.000Z","updated":"2018-01-14T09:53:31.441Z","comments":true,"path":"2017/06/01/vuejs入门/","link":"","permalink":"http://Scofieldsu.github.io/2017/06/01/vuejs入门/","excerpt":"安装 1.下载node.js安装 2.打开命令行 npm init ，输入相应信息，系统用户路径生成npm.json文件作为默认配置 3.配置npm的taobao源，加快安装速度： npm config set registry http://registry.npm.taobao.org/ 4.安装vue： npm install vue 5.安装vue脚手架，快速搭建项目结构： npm install --global vue-cli 6.开始你的项目：vue init webpack your-project-name 7.安装依赖： cd your-project-name npm install 运行 npm run dev 构建 npm build","text":"安装 1.下载node.js安装 2.打开命令行 npm init ，输入相应信息，系统用户路径生成npm.json文件作为默认配置 3.配置npm的taobao源，加快安装速度： npm config set registry http://registry.npm.taobao.org/ 4.安装vue： npm install vue 5.安装vue脚手架，快速搭建项目结构： npm install --global vue-cli 6.开始你的项目：vue init webpack your-project-name 7.安装依赖： cd your-project-name npm install 运行 npm run dev 构建 npm build 项目代码结构 build config dist inspectionProfiles noode_modules src assets components App.vue main.js static test theme … index.html package.json 其中npm install 是根据package.json中依赖安装模块到node_modules路径下。 npm run dev 会自动打开浏览器显示你的页面。 npm run build 会在dist路径下生成index.html和static文件夹，static里包括css，js，font。一般把dist中内容结合服务端显示。 学习vue的常用插件 vue官网:http://cn.vuejs.org/v2/guide/ vue-router(官方路由插件): https://router.vuejs.org/zh-cn/ axios(ajax插件): http://www.kancloud.cn/yunye/axios/234845 界面UI: http://element.eleme.io/#/zh-CN/component/installation 树形控件ztree: http://www.treejs.cn/v3/main.php#_zTreeInfo vuex(全局状态管理): https://vuex.vuejs.org/zh-cn/ 推荐学习路线 安装完成后，可以根据网上视频学习做出简单的todolist，用来熟悉开发过程。 从github学习vue-admin项目，了解多页面系统怎么使用插件。 可以自由使用插件搭建你想做的应用。 学习插件的使用可以帮你更好的完成目标，学习github上项目的代码结构，帮助你在开发复杂项目时有条不紊。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://Scofieldsu.github.io/categories/frontend/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://Scofieldsu.github.io/tags/npm/"},{"name":"vue.js","slug":"vue-js","permalink":"http://Scofieldsu.github.io/tags/vue-js/"},{"name":"elementUI","slug":"elementUI","permalink":"http://Scofieldsu.github.io/tags/elementUI/"},{"name":"axios","slug":"axios","permalink":"http://Scofieldsu.github.io/tags/axios/"},{"name":"vuex","slug":"vuex","permalink":"http://Scofieldsu.github.io/tags/vuex/"}]},{"title":"npm 详解","slug":"npm详解","date":"2017-05-13T16:02:58.000Z","updated":"2018-01-14T18:09:13.691Z","comments":true,"path":"2017/05/14/npm详解/","link":"","permalink":"http://Scofieldsu.github.io/2017/05/14/npm详解/","excerpt":"npm相关知识 NPM作为Node的模块管理和发布工具，作用与Ruby的gem、Python的pypl或setuptools、PHP的pear和.Net的Nuget一样。 包含文件内容符合规范package.json文件的目录或归档文件。并通过”package-name”@”version”来唯一标识每个包。 npm init 命令在当前工作目录下以用户引导的方式创建一个全新的package.json文件。然后通过 npm help json 命令打开帮助文档，并根据实际的项目需求自行初始化package.json的项目即可 dependencies、devDependencies 可选项，用于配置模块的生产环境依赖包和开发环境依赖包。当执行npm install时，npm会根据这两个配置项的值去下载安装相关的依赖包。两者的区别是devDependencies是模块开发过程的依赖包（如：grunt只在开发时有用的模块），并且当其他模块需要依赖当前模块时，当通过npm install “package-name”时会自动下载安装dependencies的包而不会下载devDependencies的包。","text":"npm相关知识 NPM作为Node的模块管理和发布工具，作用与Ruby的gem、Python的pypl或setuptools、PHP的pear和.Net的Nuget一样。 包含文件内容符合规范package.json文件的目录或归档文件。并通过”package-name”@”version”来唯一标识每个包。 npm init 命令在当前工作目录下以用户引导的方式创建一个全新的package.json文件。然后通过 npm help json 命令打开帮助文档，并根据实际的项目需求自行初始化package.json的项目即可 dependencies、devDependencies 可选项，用于配置模块的生产环境依赖包和开发环境依赖包。当执行npm install时，npm会根据这两个配置项的值去下载安装相关的依赖包。两者的区别是devDependencies是模块开发过程的依赖包（如：grunt只在开发时有用的模块），并且当其他模块需要依赖当前模块时，当通过npm install “package-name”时会自动下载安装dependencies的包而不会下载devDependencies的包。 查看配置 查看部分配置信息—— npm config ls 查看所有配置信息—— npm config ls -l 修改配置信息的三种方式： 直接修改配置文件 修改用户家目录的.npmrc文件（没有则新建一个）； 通过命令修改 npm config set “config” “config-value” 命令； npm config set registry http://registry.npm.taobao.org/ npm config set proxy http://proxy.com:8081/ 通过追加命令 比如–registry=”registry-uri”等命令可选项临时配置。 npm install grunt –registry=http://registry.npm.taobao.org 包的种类 全局包 用作在cli上直接调用，而无法在项目中通过require导入依赖包。如将grunt-cli安装到全局时，则可在cli中输入grunt调用了！ npm install -g grunt-cli cmd或shell中直接调用 grunt 本地包 用作在项目中通过require导入依赖包，供项目使用。 那么全局和本地的依赖包到底是存放在哪里的呢？通过 npm root -g 和 npm root 可分别查看全局和本地的依赖包下载安装的绝对目录了。 包的搜索 搜索依赖包， npm search “package-name” 查看依赖包的package.json信息， npm view “package-name” 另外我们可以单独查看package.json某个配置。 查看包的依赖关系 npm view “package-name” dependencies 查看包的源文件地址 npm view “package-name” repository.url 查看包所依赖的node版本号 npm view “package-name” engines 查看本地包信息 查看当前项目的本地依赖包， npm list 查看全局依赖包， npm list -g 查看本地依赖包是否不是最新版 npm outdated “package-name” 安装、卸载、更新包 安装包 本地 npm install “package-name” 全局 npm install -g “package-name” 这样会安装最新版的包，若需要安装特定版本，则 npm install “package-name”@“version” 卸载包 卸载本地 npm uninstall “package-name” 卸载全局 npm uninstall -g “package-name” 更新包 更新本地 npm update “package-name” 更新全局 npm update -g “package-name”","categories":[{"name":"frontend","slug":"frontend","permalink":"http://Scofieldsu.github.io/categories/frontend/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://Scofieldsu.github.io/tags/npm/"}]},{"title":"centos7 安装docker1.26","slug":"centos7安装docker","date":"2017-05-08T12:47:23.000Z","updated":"2018-01-14T18:07:58.063Z","comments":true,"path":"2017/05/08/centos7安装docker/","link":"","permalink":"http://Scofieldsu.github.io/2017/05/08/centos7安装docker/","excerpt":"","text":"安装yum-utils，它提供yum-config-manager实用程序： sudo yum install -y yum-utils 使用以下命令设置稳定版本库： sudo yum-config-manager –add-repo https://docs.docker.com/v1.13/engine/installation/linux/repo_files/centos/docker.repo 更新yum包索引。 sudo yum makecache fast 安装特定版本 yum list docker-engine.x86_64 --showduplicates |sort -r sudo yum -y install docker-engine-1.12.6-1.el7.centos 启动服务 sudo systemctl start docker systemctl enable docker","categories":[{"name":"devops","slug":"devops","permalink":"http://Scofieldsu.github.io/categories/devops/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://Scofieldsu.github.io/tags/docker/"},{"name":"centos7","slug":"centos7","permalink":"http://Scofieldsu.github.io/tags/centos7/"}]},{"title":"ubuntu安装odoo环境","slug":"ubuntu安装odoo环境","date":"2016-12-08T13:13:45.000Z","updated":"2018-01-14T09:53:31.438Z","comments":true,"path":"2016/12/08/ubuntu安装odoo环境/","link":"","permalink":"http://Scofieldsu.github.io/2016/12/08/ubuntu安装odoo环境/","excerpt":"ubuntu安装odoo环境 接触odoo几个月的期间，刚开始装环境也是缺东少西，按照文档一步一步来，后来慢慢理解了需要装什么，哪些是必要的。自己工作中使用了ubuntu系统，后来换成mac也在mac上装了环境，不同人安装可能遇到的问题也不一样，但只要知道我们需要什么，就万变不离其宗，我认为可以分为这几块：odoo源码；postgresql数据库；nodejs和less；运行odoo环境的python依赖包。 于是可以围绕这几点开始安装。第一，odoo源码。建议从github上clone下来 odoo9或odoo10源码。两者的目录结构有细微变动，而且在启动服务时运行的文件不一样。odoo9运行的是odoo.py，其配置文件是odoo-9.0/debian/openerp-server.conf，odoo10运行的是odoo.bin,其配置文件是odoo10/debian/odoo.conf。第二安装postgresql数据库。ubuntu可以命令行安装，mac上可以下载postgresql.app比较方便。第三nodejs和lessc参照其他网上教程。第四安装运行需要的python依赖包，网上有个requirement.txt一次运行安装所有依赖包，对于没有安装成功的包，具体问题具体分析对待。 安装postgresql：sudo apt-get install postgresql ; 检查安装：psql --version","text":"ubuntu安装odoo环境 接触odoo几个月的期间，刚开始装环境也是缺东少西，按照文档一步一步来，后来慢慢理解了需要装什么，哪些是必要的。自己工作中使用了ubuntu系统，后来换成mac也在mac上装了环境，不同人安装可能遇到的问题也不一样，但只要知道我们需要什么，就万变不离其宗，我认为可以分为这几块：odoo源码；postgresql数据库；nodejs和less；运行odoo环境的python依赖包。 于是可以围绕这几点开始安装。第一，odoo源码。建议从github上clone下来 odoo9或odoo10源码。两者的目录结构有细微变动，而且在启动服务时运行的文件不一样。odoo9运行的是odoo.py，其配置文件是odoo-9.0/debian/openerp-server.conf，odoo10运行的是odoo.bin,其配置文件是odoo10/debian/odoo.conf。第二安装postgresql数据库。ubuntu可以命令行安装，mac上可以下载postgresql.app比较方便。第三nodejs和lessc参照其他网上教程。第四安装运行需要的python依赖包，网上有个requirement.txt一次运行安装所有依赖包，对于没有安装成功的包，具体问题具体分析对待。 安装postgresql：sudo apt-get install postgresql ; 检查安装：psql --version 安装pip: sudo apt-get install python-pip 切换postgres用户：sudo su - postgres 创建新的数据库用户yuyuan：createuser --createdb --username postgres --no-createrole --no-superuser --pwprompt yuyuan 退出用户：exit 安装各个依赖包：sudo apt-get install python-dateutil python-docutils python-feedparser python-gdata python-jinja2 python-ldap python-libxslt1 python-lxml python-mako python-mock python-openid python-psycopg2 python-psutil python-pybabel python-pychart python-pydot python-pyparsing python-reportlab python-simplejson python-tz python-unittest2 python-vatnumber python-vobject python-webdav python-werkzeug python-xlwt python-yaml python-zsi python-pyPdf python-decorator python-passlib python-requests 其中pypdf如不能安装，www.python.org下载pyPdf.tar.gz 解压 tar zxvf pyPdf.tar.gz,进入文件夹，sudo python setup.py install 安装nodes：sudo apt -get install nodes-legacy;sudo apt install -y npm;sudo npm install -g less less-plugin-clean-css;sudo ln -s /usr/bin/nodejs /usr/bin/node 安装git ：sudo apt-get install git 进入某个目录：git clone -b 9.0 https://github.com/odoo/odoo.git . 安装pgadmin3: sudo apt-get install pgadmin3 安装sublime text3：sudo add-apt-repository ppa:webupd8team/sublime-text-3；sudo apt-get update ；sudo apt-get install sublime-text-installer","categories":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://Scofieldsu.github.io/categories/ubuntu/"}],"tags":[{"name":"python","slug":"python","permalink":"http://Scofieldsu.github.io/tags/python/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://Scofieldsu.github.io/tags/ubuntu/"},{"name":"odoo","slug":"odoo","permalink":"http://Scofieldsu.github.io/tags/odoo/"},{"name":"postgresql","slug":"postgresql","permalink":"http://Scofieldsu.github.io/tags/postgresql/"}]},{"title":"python(3):内存管理机制","slug":"python(3)-内存管理机制","date":"2016-08-01T14:01:27.000Z","updated":"2018-01-14T18:06:08.402Z","comments":true,"path":"2016/08/01/python(3)-内存管理机制/","link":"","permalink":"http://Scofieldsu.github.io/2016/08/01/python(3)-内存管理机制/","excerpt":"内存管理机制简要 内存池 Python的内存机制以金字塔行，-1，-2层主要有操作系统进行操作， 第0层是C中的malloc，free等内存分配和释放函数进行操作； 第1层和第2层是内存池，有Python的接口函数PyMem_Malloc函数实现，当对象小于256K时有该层直接分配内存； 第3层是最上层，也就是我们对Python对象的直接操作； python的内存在底层也是由malloc和free的方式来分配和释放， 主要通过两种机制来实现，一个是引用计数，一个是垃圾回收。前者负责确定当前变量是否需要释放，后者解决前者解决不了的循环引用问题以及提供手动释放的接口。 Python中所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的 malloc。 Python使用Pymalloc管理内存。在Python中，会频繁的创建和删除很多小对象，如果这些对象的内存申请和释放都使用malloc()和free()，将会带来严重的性能问题。因此，Pymalloc分配一系列256KB的内存块，称之为arena。每个arena分割为4KB大小的内存池Pool，每个Pool再切分为固定大小的Block。在内存分配时，分配给进程的就是这些Blocks。 引用计数(reference counting) 每个对象都有引用计数器count，为0的时候，且不在缓冲区则被释放。 12345import sysa=[]sys.getrefcount(a)&gt;&gt;2因为getrefcount参数a临时引用 垃圾回收(Garbage Collection) gc模块采用了分代回收方法，将对象根据存活的时间分为三“代”，所有新建的对象都是0代，当0代对象经过一次自动垃圾回收，没有被释放的对象会被归入1代，同理1代归入2代。每次当0代对象中引用数为0的对象超过700个时，启动一次0代对象扫描垃圾回收，经过10次的0代回收，就进行一次0代和1代回收，1代回收次数超过10次，就会进行一次0代、1代和2代回收。gc模块还提供了手动回收的函数，即gc.collect()。 gc.get_threshold() 返回（700,10,10） 垃圾回收还有一个重要功能是，解决循环引用的问题，通常发生在某个变量a引用了自己或者变量a与b互相引用。 Python 的 GC 设计是，对于内部不包含指向其他对象的引用的对象（如字符串、数值类型等非容器对象），采用引用计数，因为这些对象根本不可能产生循环引用。对于 List、Map 等可能产生循环引用的对象，则采用 mark-sweep。（标记-清除) 标记-清除 计算有效引用计数，为0可回收","text":"内存管理机制简要 内存池 Python的内存机制以金字塔行，-1，-2层主要有操作系统进行操作， 第0层是C中的malloc，free等内存分配和释放函数进行操作； 第1层和第2层是内存池，有Python的接口函数PyMem_Malloc函数实现，当对象小于256K时有该层直接分配内存； 第3层是最上层，也就是我们对Python对象的直接操作； python的内存在底层也是由malloc和free的方式来分配和释放， 主要通过两种机制来实现，一个是引用计数，一个是垃圾回收。前者负责确定当前变量是否需要释放，后者解决前者解决不了的循环引用问题以及提供手动释放的接口。 Python中所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的 malloc。 Python使用Pymalloc管理内存。在Python中，会频繁的创建和删除很多小对象，如果这些对象的内存申请和释放都使用malloc()和free()，将会带来严重的性能问题。因此，Pymalloc分配一系列256KB的内存块，称之为arena。每个arena分割为4KB大小的内存池Pool，每个Pool再切分为固定大小的Block。在内存分配时，分配给进程的就是这些Blocks。 引用计数(reference counting) 每个对象都有引用计数器count，为0的时候，且不在缓冲区则被释放。 12345import sysa=[]sys.getrefcount(a)&gt;&gt;2因为getrefcount参数a临时引用 垃圾回收(Garbage Collection) gc模块采用了分代回收方法，将对象根据存活的时间分为三“代”，所有新建的对象都是0代，当0代对象经过一次自动垃圾回收，没有被释放的对象会被归入1代，同理1代归入2代。每次当0代对象中引用数为0的对象超过700个时，启动一次0代对象扫描垃圾回收，经过10次的0代回收，就进行一次0代和1代回收，1代回收次数超过10次，就会进行一次0代、1代和2代回收。gc模块还提供了手动回收的函数，即gc.collect()。 gc.get_threshold() 返回（700,10,10） 垃圾回收还有一个重要功能是，解决循环引用的问题，通常发生在某个变量a引用了自己或者变量a与b互相引用。 Python 的 GC 设计是，对于内部不包含指向其他对象的引用的对象（如字符串、数值类型等非容器对象），采用引用计数，因为这些对象根本不可能产生循环引用。对于 List、Map 等可能产生循环引用的对象，则采用 mark-sweep。（标记-清除) 标记-清除 计算有效引用计数，为0可回收 【以下转自】chenrudan.github.io 本文主要为了解释清楚python的内存管理机制，首先介绍了一下python关于内存使用的一些基本概念，然后介绍了引用计数和垃圾回收gc模块，并且解释了分代回收和“标记-清除”法，然后分析了一下各种操作会导致python变量和对象的变化，最后做了一下小结。本来是为了解决前几天遇到把服务器内存耗光的问题，结果后来检查发现并不是因为内存管理的问题… Python变量、对象、引用、存储 Python内存管理机制和操作对变量的影响 2.1 内存管理机制 2.2 各种操作对变量地址的改变 小结 引用 Python变量、对象、引用、存储 python语言是一种解释性的编程语言，它不同于一些传统的编译语言，不是先编译成汇编再编程机器码，而是在运行的过程中，逐句将指令解释成机器码，所以造就了python语言一些特别的地方。例如a=1，其中a是变量，1是对象。这里所谓的变量，它的意义类似一个指针，它本身是没有类型的，只有它指向的那个对象是什么类型，它才是什么类型，一旦把它指到别的地方，它的类型就变了，现在指向的是1，它的类型可以认为是int，假如接下来执行a=2.5，那么变量的类型就变了。甚至当先给a=1，a=a+1时，a的地址也会改变。而这里的1,2.5或者一个list一个dict就是一个被实例化的对象，对象拥有真正的资源与取值，当一个变量指向某个对象，被称为这个对象的产生了一个引用，一个对象可以有多个变量指向它，有多个引用。而一个变量可以随时指向另外的对象。同时一个变量可以指向另外一个变量，那么它们指向的那个对象的引用就增加了一个。 Python有个特别的机制，它会在解释器启动的时候事先分配好一些缓冲区，这些缓冲区部分是固定好取值，例如整数[-5,256]的内存地址是固定的(这里的固定指这一次程序启动之后，这些数字在这个程序中的内存地址就不变了，但是启动新的python程序，两次的内存地址不一样)。有的缓冲区就可以重复利用。这样的机制就使得不需要python频繁的调用内存malloc和free。下面的id是取内存地址，hex是转成16进制表示。 1234567891011121314151617#第一次启动解释器&gt;&gt;&gt; hex(id(1))'0x14c5158'#第二次启动解释器&gt;&gt;&gt; hex(id(1))'0xe17158'#缓冲区被重复利用&gt;&gt;&gt; hex(id(100000))'0xe5be00'&gt;&gt;&gt; hex(id(1000000))'0xe5be00'&gt;&gt;&gt; hex(id(10000000))'0xe5be00'&gt;&gt;&gt; hex(id(100000000))'0xe5be00' 针对整数对象，它的内存区域似乎是一个单独的区域，跟string、dict等的内存空间都不一样，从实验结果来看，它的地址大小只有’0xe5be00’，其他的是’0x7fe7e03c7698’。而存储整数对象的这块区域，有一块内存区域是事先分配好的，即[-5,256]范围内的整数。这块称为小整数缓冲池，静态分配，对某个变量赋值就是直接从里面取就行了，在python初始化时被创建。而另外的整数缓冲池称为大整数缓冲池，这块内存也是已经分配好了，只是要用的时候再赋值。可以从下面的例子中看到，针对257这个数字，虽然给a和b赋了相同的值，但是解释器实际上是先分配了不同的地址，再把这个地址给两个变量。 123456789101112&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = 1&gt;&gt;&gt; hex(id(a))'0xe17158'&gt;&gt;&gt; hex(id(b))'0xe17158'&gt;&gt;&gt; b = 257&gt;&gt;&gt; a = 257&gt;&gt;&gt; hex(id(a))'0xe5be00'&gt;&gt;&gt; hex(id(b))'0xe5bdd0' 针对string类型，它也有自己的缓冲区，也是分为固定缓冲区和可重复缓冲区，固定的是256个ASCII码字符。还发现一个有意思的现象，string中只要不出现除了字母和数字其他字符，那么对a和b赋同样的值，它们的内存地址都相同。但是如果string对象中有其他字符，那么对两个变量赋相同的string值，它们的内存地址还是不一样的。 1234567891011121314&gt;&gt;&gt; b = 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'&gt;&gt;&gt; hex(id(b))'0x7fe7e03af848'&gt;&gt;&gt; a = 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'&gt;&gt;&gt; hex(id(a))'0x7fe7e03af848'&gt;&gt;&gt; a = 'abcd%'&gt;&gt;&gt; b = 'abcd%'&gt;&gt;&gt; hex(id(a))'0x7fe7e02d4900'&gt;&gt;&gt; hex(id(b))'0x7fe7e02d48d0' 而另外的dict和list的缓冲区也是事先分配好，大小为80个对象。 因此变量的存储有三个区域，事先分配的静态内存、事先分配的可重复利用内存以及需要通过malloc和free来控制的自由内存。 Python内存管理机制和操作对变量的影响 2.1 内存管理机制 python的内存在底层也是由malloc和free的方式来分配和释放，只是它代替程序员决定什么时候分配什么时候释放，同时也提供接口让用户手动释放，因此它有自己的一套内存管理体系，主要通过两种机制来实现，一个是引用计数，一个是垃圾回收。前者负责确定当前变量是否需要释放，后者解决前者解决不了的循环引用问题以及提供手动释放的接口[2]。 引用计数(reference counting)，针对可以重复利用的内存缓冲区和内存，python使用了一种引用计数的方式来控制和判断某快内存是否已经没有再被使用。即每个对象都有一个计数器count，记住了有多少个变量指向这个对象，当这个对象的引用计数器为0时，假如这个对象在缓冲区内，那么它地址空间不会被释放，而是等待下一次被使用，而非缓冲区的该释放就释放。 这里通过sys包中的getrefcount()来获取当前对象有多少个引用。这里返回的引用个数分别是2和3，比预计的1和2多了一个，这是因为传递参数给getrefcount的时候产生了一个临时引用[1]。 123456&gt;&gt;&gt; a = []&gt;&gt;&gt; getrefcount(a)2&gt;&gt;&gt; b = a&gt;&gt;&gt; getrefcount(a)3 当一个变量通过另外一个变量赋值，那么它们的对象引用计数就增加1，当其中一个变量指向另外的地方，之前的对象计数就减少1。 12345678910111213&gt;&gt;&gt; a = []&gt;&gt;&gt; getrefcount(a)2&gt;&gt;&gt; b = a&gt;&gt;&gt; getrefcount(a)3&gt;&gt;&gt; getrefcount(b)3&gt;&gt;&gt; b = []&gt;&gt;&gt; getrefcount(a)2&gt;&gt;&gt; getrefcount(b)2 垃圾回收(Garbage Collection)python提供了del方法来删除某个变量，它的作用是让某个对象引用数减少1。当某个对象引用数变为0时并不是直接将它从内存空间中清除掉，而是采用垃圾回收机制gc模块，当这些引用数为0的变量规模达到一定规模，就自动启动垃圾回收，将那些引用数为0的对象所占的内存空间释放。这里gc模块采用了分代回收方法，将对象根据存活的时间分为三“代”，所有新建的对象都是0代，当0代对象经过一次自动垃圾回收，没有被释放的对象会被归入1代，同理1代归入2代。每次当0代对象中引用数为0的对象超过700个时，启动一次0代对象扫描垃圾回收，经过10次的0代回收，就进行一次0代和1代回收，1代回收次数超过10次，就会进行一次0代、1代和2代回收。而这里的几个值是通过查询get_threshold()返回(700,10,10)得到的。此外，gc模块还提供了手动回收的函数，即gc.collect()。 1234567&gt;&gt;&gt; a = []&gt;&gt;&gt; b = a&gt;&gt;&gt; getrefcount(a)3&gt;&gt;&gt; del b&gt;&gt;&gt; getrefcount(a)2 而垃圾回收还有一个重要功能是，解决循环引用的问题，通常发生在某个变量a引用了自己或者变量a与b互相引用。考虑引用自己的情况，可以从下面的例子中看到，a所指向的内存对象有3个引用，但是实际上只有两个变量，假如把这两个变量都del掉，对象引用个数还是1，没有变成0，这种情况下，如果只有引用计数的机制，那么这块没有用的内存会一直无法释放掉。因此python的gc模块利用了“标记-清除”法，即认为有效的对象之间能通过有向图连接起来，其中图的节点是对象，而边是引用，下图中obj代表对象，ref代表引用，从一些不能被释放的对象节点出发(称为root object，一些全局引用或者函数栈中的引用[5]，例如下图的obj_1，箭头表示obj_1引用了obj_2)遍历各代引用数不为0的对象。在python源码中，每个变量不仅有一个引用计数，还有一个有效引用计数gc_ref，后者一开始等于前者，但是启动标记清除法开始遍历对象时，从root object出发(初始图中的gc_ref为(1,1,1,1,1,1,1))，当对象i引用了对象j时，将对象j的有效引用个数减去1，这样下图中各个对象有效引用个数变为了(1, 0, 0, 0, 0, 0, 0)，接着将所有对象分配到两个表中，一个是reachable对象表，一个是unreachable对象表，root object和在图中能够直接或者间接与它们相连的对象就放入reachable，而不能通过root object访问到且有效引用个数变为0的对象作为放入unreachable，从而通过这种方式来消去循环引用的影响。 在人工调用gc.collect()的时候会有一个返回值，这个返回值就是这一次扫描unreachable的对象个数。在上面谈到的每一代的回收过程中，都会启用“标记-清除”法。 1234567891011121314&gt;&gt;&gt; a = []&gt;&gt;&gt; b = a&gt;&gt;&gt; getrefcount(b)3&gt;&gt;&gt; a.append(a)&gt;&gt;&gt; getrefcount(b)4&gt;&gt;&gt; del a&gt;&gt;&gt; getrefcount(b)3&gt;&gt;&gt; del b&gt;&gt;&gt; unreachable = gc.collect()&gt;&gt;&gt; unreachable1 图1 变量形成的有向图 2.2 各种操作对变量地址的改变 当处理赋值、加减乘除时，这些操作实际上导致变量指向的对象发生了改变，已经不是原来的那个对象了，并不是通过这个变量来改变它指向的对象的值。 123456789101112131415&gt;&gt;&gt; a = 10&gt;&gt;&gt; hex(id(a))'0xe17080'&gt;&gt;&gt; a = a - 1&gt;&gt;&gt; hex(id(a))'0xe17098'&gt;&gt;&gt; a = a + 1&gt;&gt;&gt; hex(id(a))'0xe17080'&gt;&gt;&gt; a = a * 10&gt;&gt;&gt; hex(id(a))'0xe177a0'&gt;&gt;&gt; a = a / 2&gt;&gt;&gt; hex(id(a))'0xe17488' 增加减少list、dict对象内容是在对对象本身进行操作，此时变量的指向并没有改变，它作为对象的一个别名/引用，通过操纵变量来改变对应的对象内容。但是一旦将变量赋值到别的地方去，那么变量地址就改变了。 12345678910111213141516171819202122&gt;&gt;&gt; a = []&gt;&gt;&gt; hex(id(a))'0x7fe7e02caef0'&gt;&gt;&gt; a.append(1)&gt;&gt;&gt; hex(id(a))'0x7fe7e02caef0'&gt;&gt;&gt; a = [1]&gt;&gt;&gt; hex(id(a))'0x7fe7e02caea8'当把一个list变量赋值给另外一个变量时，这两个变量是等价的，它们都是原来对象的一个引用。&gt;&gt;&gt; a = []&gt;&gt;&gt; b = a&gt;&gt;&gt; a.append(1)&gt;&gt;&gt; b[1]&gt;&gt;&gt; hex(id(a))'0x7fe7e02caea8'&gt;&gt;&gt; hex(id(b))'0x7fe7e02caea8' 但是实际使用中，可能需要的是将里面的内容给复制出来到一个新的地址空间，这里可以使用python的copy模块，copy模块分为两种拷贝，一种是浅拷贝，一种是深拷贝。假设处理一个list对象，浅拷贝调用函数copy.copy()，产生了一块新的内存来存放list中的每个元素引用，也就是说每个元素的跟原来list中元素地址是一样的。所以从下面例子中可看出当原list中要是包含list对象，分别在a和b对list元素做操作时，两边都受到了影响。此外，通过b=list(a)来对变量b赋值时，也跟浅拷贝的效果一样。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&gt;&gt;&gt; a = [1, 1000, ['a', 'b']]&gt;&gt;&gt; b = copy.copy(a)&gt;&gt;&gt; b[1, 1000, ['a', 'b']]&gt;&gt;&gt; hex(id(a))'0x7fe7e02e1368'&gt;&gt;&gt; hex(id(b))'0x7fe7e02e1518'&gt;&gt;&gt; hex(id(a[2]))'0x7fe7e02caea8'&gt;&gt;&gt; hex(id(b[2]))'0x7fe7e02caea8'&gt;&gt;&gt; a[2].append('a+')&gt;&gt;&gt; a[1, 1000, ['a', 'b', 'a+']]&gt;&gt;&gt; b[1, 1000, ['a', 'b', 'a+']]&gt;&gt;&gt; b[2].append('b+')&gt;&gt;&gt; a[1, 1000, ['a', 'b', 'a+', 'b+']]&gt;&gt;&gt; b[1, 1000, ['a', 'b', 'a+', 'b+']]&gt;&gt;&gt; a[0] = 2&gt;&gt;&gt; a[2, 1000, ['a', 'b', 'a+', 'b+']]&gt;&gt;&gt; b[1, 1000, ['a', 'b', 'a+', 'b+']]而深拷贝则调用copy.deepcopy()，它将原list中每个元素都复制了值到新的内存中去了，因此跟原来的元素地址不相同，那么再对a和b的元素做操作，就是互相不影响了。&gt;&gt;&gt; a = [1, 1000, ['a', 'b']]&gt;&gt;&gt; b = copy.deepcopy(a)&gt;&gt;&gt; hex(id(a))'0x7fe7e02cae18'&gt;&gt;&gt; hex(id(b))'0x7fe7e02e1368'&gt;&gt;&gt; hex(id(a[2]))'0x7fe7e02e14d0'&gt;&gt;&gt; hex(id(b[2]))'0x7fe7e02e1320'&gt;&gt;&gt; a[2].append('a+')&gt;&gt;&gt; a[1, 1000, ['a', 'b', 'a+']]&gt;&gt;&gt; b[1, 1000, ['a', 'b']]&gt;&gt;&gt; b[2].append('b+')&gt;&gt;&gt; a[1, 1000, ['a', 'b', 'a+']]&gt;&gt;&gt; b[1, 1000, ['a', 'b', 'b+']]当把一个变量传入一个函数时，它对应的对象引用个数增加2。 小结 本来是因为前天把128g的服务器用死机了，想搞清楚为什么会导致那个问题，写完这篇去检查了一下，发现并不是因为对内存的使用有误导致的，而是因为我用到了多次hist函数，这个函数占了内存，换成了numpy的histgram函数就好了。不过写完也觉得很有意思，特别是垃圾回收其实是一个比较重要的不仅局限于python语言的一个东西，看了不少博客直接拿源码过来分析也是好牛的感觉。而对于标记清除法，个人不是特别理解为什么要加有效引用计数，那些循环引用的一个对象或者两个三个对象不应该跟有效的对象本来就是隔离开的，既然在遍历的时候，就能知道哪些对象是访问不到的，那么这些对象不就应该形成了环么。 引用 [1] Python深入06 Python的内存管理 [2] Python Garbage Collection [3] Python内存池管理与缓冲池设计 [4] Python垃圾回收机制:gc模块 [5] 《Python源码剖析》，陈儒著，2008","categories":[{"name":"python","slug":"python","permalink":"http://Scofieldsu.github.io/categories/python/"}],"tags":[{"name":"内存管理","slug":"内存管理","permalink":"http://Scofieldsu.github.io/tags/内存管理/"},{"name":"gc","slug":"gc","permalink":"http://Scofieldsu.github.io/tags/gc/"},{"name":"引用计数","slug":"引用计数","permalink":"http://Scofieldsu.github.io/tags/引用计数/"}]},{"title":"When you are old","slug":"When-you-are-old","date":"2016-07-14T17:46:58.000Z","updated":"2018-01-14T18:01:20.918Z","comments":true,"path":"2016/07/15/When-you-are-old/","link":"","permalink":"http://Scofieldsu.github.io/2016/07/15/When-you-are-old/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031When you are oldYeatsWhen you are old and grey and full of sleep,And nodding by the fire, take down this book,And slowly read, and dream of the soft lookYour eyes had once, and of their shadows deep;How many loved your moments of glad grace,And loved your beauty with love false or true,But one man loved the pilgrim Soul in you,And loved the sorrows of your changing face;And bending down beside the glowing bars,Murmur, a little sadly, how Love fledAnd paced upon the mountains overheadAnd hid his face amid a crowd of stars.","categories":[{"name":"诗和小说以及文章","slug":"诗和小说以及文章","permalink":"http://Scofieldsu.github.io/categories/诗和小说以及文章/"}],"tags":[{"name":"The_Life_You_Want","slug":"The-Life-You-Want","permalink":"http://Scofieldsu.github.io/tags/The-Life-You-Want/"}]},{"title":"百年孤独","slug":"百年孤独","date":"2016-07-14T17:45:21.000Z","updated":"2018-01-14T17:57:54.562Z","comments":true,"path":"2016/07/15/百年孤独/","link":"","permalink":"http://Scofieldsu.github.io/2016/07/15/百年孤独/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334心属于你的我借来寄托却变成我的心魔你属于谁的我刚好经过却带来潮起潮落都是因为一路上一路上大雨曾经滂沱证明你有来过可是当我闭上眼再睁开眼只看见沙漠哪里有什么骆驼背影是真的人是假的没什么执著一百年前你不是你我不是我悲哀是真的泪是假的本来没因果一百年后没有你也没有我风属于天的 我借来吹吹却吹起人间烟火天属于谁的我借来欣赏却看到你的轮廓","categories":[{"name":"诗和小说以及文章","slug":"诗和小说以及文章","permalink":"http://Scofieldsu.github.io/categories/诗和小说以及文章/"}],"tags":[{"name":"The_Life_You_Want","slug":"The-Life-You-Want","permalink":"http://Scofieldsu.github.io/tags/The-Life-You-Want/"}]},{"title":"Scofield.yu","slug":"Scofield-yu","date":"2016-07-06T18:43:51.000Z","updated":"2018-01-14T09:53:31.430Z","comments":true,"path":"2016/07/07/Scofield-yu/","link":"","permalink":"http://Scofieldsu.github.io/2016/07/07/Scofield-yu/","excerpt":"欢迎使用马克飞象 @(示例笔记本)[马克飞象|帮助|Markdown] 马克飞象是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述： 功能丰富 ：支持高亮代码块、LaTeX 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手； 得心应手 ：简洁高效的编辑器，提供桌面客户端以及离线Chrome App，支持移动端 Web； 深度整合 ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。","text":"欢迎使用马克飞象 @(示例笔记本)[马克飞象|帮助|Markdown] 马克飞象是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述： 功能丰富 ：支持高亮代码块、LaTeX 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手； 得心应手 ：简洁高效的编辑器，提供桌面客户端以及离线Chrome App，支持移动端 Web； 深度整合 ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。 [TOC] Markdown简介 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— 维基百科 正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接或一个脚注[1]。下面列举了几个高级功能，更多语法请按Ctrl + /查看帮助。 代码块 12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' LaTeX 公式 可以创建行内公式，例如 Γ(n)=(n−1)!∀n∈N\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb NΓ(n)=(n−1)!∀n∈N。或者块级公式： x=−b±b2−4ac2ax = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} x=​2a​​−b±√​b​2​​−4ac​​​​​ 表格 Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 流程图 12345678st=&gt;start: Starte=&gt;endop=&gt;operation: My Operationcond=&gt;condition: Yes or No?st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 以及时序图: 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 提示：想了解更多，请查看流程图语法以及时序图语法。 复选框 使用 - [ ] 和 - [x] 语法可以创建复选框，实现 todo-list 等功能。例如： [x] 已完成事项 [ ] 待办事项1 [ ] 待办事项2 注意：目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在马克飞象中修改 Markdown 原文才可生效。下个版本将会全面支持。 印象笔记相关 笔记本和标签 马克飞象增加了@(笔记本)[标签A|标签B]语法, 以选择笔记本和添加标签。 绑定账号后， 输入(自动会出现笔记本列表，请从中选择。 笔记标题 马克飞象会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 欢迎使用马克飞象。 快捷编辑 保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到马克飞象中打开并编辑该笔记。 **注意：**目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。 数据同步 马克飞象通过将Markdown原文以隐藏内容保存在笔记中的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。 隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。 离线存储 马克飞象使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过文档管理打开。 **注意：**虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，请务必经常及时同步到印象笔记。 编辑器相关 设置 右侧系统菜单（快捷键Ctrl + M）的设置中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。 快捷键 帮助 Ctrl + / 同步文档 Ctrl + S 创建文档 Ctrl + Alt + N 最大化编辑器 Ctrl + Enter 预览文档 Ctrl + Alt + Enter 文档管理 Ctrl + O 系统菜单 Ctrl + M 加粗 Ctrl + B 插入图片 Ctrl + G 插入链接 Ctrl + L 提升标题 Ctrl + H 关于收费 马克飞象为新用户提供 10 天的试用期，试用期过后需要续费才能继续使用。未购买或者未及时续费，将不能同步新的笔记。之前保存过的笔记依然可以编辑。 反馈与建议 微博：@马克飞象，@GGock 邮箱：hustgock@gmail.com 感谢阅读这份帮助文档。请点击右上角，绑定印象笔记账号，开启全新的记录与分享体验吧。 这是一个示例脚注。请查阅 MultiMarkdown 文档 关于脚注的说明。 限制： 印象笔记的笔记内容使用 ENML 格式，基于 HTML，但是不支持某些标签和属性，例如id，这就导致脚注和TOC无法正常点击。 ↩︎","categories":[],"tags":[]},{"title":"热爱生命","slug":"热爱生命","date":"2016-06-03T14:54:04.000Z","updated":"2018-01-14T09:53:31.416Z","comments":true,"path":"2016/06/03/热爱生命/","link":"","permalink":"http://Scofieldsu.github.io/2016/06/03/热爱生命/","excerpt":"","text":"","categories":[{"name":"诗和小说以及文章","slug":"诗和小说以及文章","permalink":"http://Scofieldsu.github.io/categories/诗和小说以及文章/"}],"tags":[{"name":"The_Life_You_Want","slug":"The-Life-You-Want","permalink":"http://Scofieldsu.github.io/tags/The-Life-You-Want/"}]},{"title":"初相遇","slug":"初相遇","date":"2016-05-18T15:44:23.000Z","updated":"2018-01-14T17:58:29.174Z","comments":true,"path":"2016/05/18/初相遇/","link":"","permalink":"http://Scofieldsu.github.io/2016/05/18/初相遇/","excerpt":"","text":"1234567891011121314151617181920212223242526272829美丽的梦和美丽的诗一样，都是可遇而不可求的，常常在最没能料到的时刻里出现。我喜欢那样的梦，在梦里，一切都可以重新开始，一切都可以慢慢解释，心里甚至还能感觉到，所有被浪费的时光竟然都能重回时的狂喜与感激。胸怀中满溢着幸福，只因你就在我眼前，对我微笑，一如当年。我真喜欢那样的梦，明明知道你已为我拔涉千里，却又觉得芳草鲜美，落英缤纷，好象你我才初初相遇。","categories":[{"name":"诗和小说以及文章","slug":"诗和小说以及文章","permalink":"http://Scofieldsu.github.io/categories/诗和小说以及文章/"}],"tags":[{"name":"The_Life_You_Want","slug":"The-Life-You-Want","permalink":"http://Scofieldsu.github.io/tags/The-Life-You-Want/"}]},{"title":"命若琴弦","slug":"命若琴弦","date":"2016-05-16T14:31:46.000Z","updated":"2018-01-14T18:03:05.229Z","comments":true,"path":"2016/05/16/命若琴弦/","link":"","permalink":"http://Scofieldsu.github.io/2016/05/16/命若琴弦/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587命 若 琴 弦 *史铁生*莽莽苍苍的群山之中走着两个瞎子，一老一少，一前一后，两顶发了黑的黑帽起伏攒动，匆匆忙忙，象是随着一条不安静的河水在漂流。无所谓从哪儿来，也无所谓到哪儿去，每人带一把三弦琴，说书为生。方圆几百上千里这片大山中，峰峦叠嶂，沟壑纵横，人烟稀疏，走一天才能见一片开阔地，有几个村落。荒草丛中随时会飞起一对山鸡，跳出一只野兔、狐狸、或者其它小野兽。山谷中常有鹞鹰盘旋。寂静的群山没有一点阴影，太阳正热的凶。“把三弦子抓在手里。”老瞎子喊，在山间震起回声。 “抓在手里呢。”小瞎子回答。“操心身上的汗把三弦子弄湿了。弄湿了晚上弹你的肋条！”“抓在手里呢。”老少二人都赤着上身，各自拎了一条木棍探路，缠在腰间的粗布小褂已经被汗水湿润了一大片起来的黄土干的呛人。这正是说书的旺季。天长，村子里的人吃罢晚饭都不呆在家里；有的人晚饭也不在家吃，捧上碗至路边去，或者到场院里。老瞎子想赶着多说书，整个热季领着小瞎子一个村子紧走，一晚一晚紧说。老瞎子一天比一天紧张、激动，心理算定：弹断一千根琴弦的日子就在这个夏天了，说不定就在前面的野羊坳。暴躁了一整天的太阳这会儿正平静下来，光线开始变得深沉。远远近近的蝉鸣也舒缓了许多。“小子！你不能走快点吗？”老瞎子在前面喊，不回头也不放慢脚步。小瞎子紧跑几步，吊在屁股上的一 只大挎包叮啷哐啷地响，离老瞎子仍有几丈“野鸽子都在窝里飞啦。”“什么”小瞎子又紧走几步。“我说野鸽子都回窝了，你还不快走！”“噢。”“你又鼓捣我那 电匣子呢。”“噫――！鬼动来。”“那耳机子快让你鼓捣坏了。”“鬼动来！”老瞎子暗笑：你小子才活了几天？“蚂蚁打架我也听得着。”老瞎子说。小瞎子不争辩了，悄悄把耳机子塞到挎包里去，跟在师父身后闷闷地走路。无尽无休的无聊的 路。走了一阵子，小瞎子听见有只獾在地里啃庄稼，就使劲学狗叫，那只獾 连滚带爬地逃走了，他觉得有点开心，轻声哼了几句小调儿，哥哥呀妹妹的。师父不让他养狗，怕受村里的狗 欺负，也怕欺负了别人家的狗，误了生意。又走了一会小瞎子又听见不远处有条蛇在游动，弯腰摸了块石头砍过去，“哗啦啦”一阵子高梁叶子响。老瞎子有点可怜他了，停下来等他。“除了獾就是蛇。”小瞎子赶忙说，担心师父骂他。“有了庄稼地了，不远了。”老瞎子把一个水壶递给徒弟。“干咱们这营生的，一辈子就是走。”老瞎子又说，“累不？”小瞎子不回答，知道师父最讨厌他说累。“我师父才冤呢。就是你师爷，才冤呢。东奔西走一辈子，到了儿没弹够一千根琴弦。”小瞎子听出师父这会儿心绪好，就问：“什么上绿色的长乙（椅）？”“什么？噢，八成是一把椅子吧。”“曲折的油狼（游廊）呢？”“油狼？什么油狼？”“曲折的油狼。”“不知道。”“匣子里说的。”“你就爱瞎听那 些玩艺儿。听那些玩艺儿有什么用？天底下的好东西多啦，跟咱们有什么关系？”“我就没听您说过，什么跟咱们有关系。”小瞎子把“有”字说得重。“琴！三弦琴！你爹让你跟了我来，是为了让你弹好三弦子，学会说书。”小瞎子故意把水喝得咕噜响。再上路时小瞎子走在前头。大山的阴影在沟谷里铺开来。地势也 渐渐的平缓，开阔。接近村子的时候，老瞎子喊住小瞎子，在背阴的山脚下 找到一个小泉眼，细细的泉水从石缝里往外冒，淌下来，积成脸盆大小的水洼，周围的野草长的茂盛，水流出几十米便被干渴的土地吸干。“过来洗洗吧，洗洗你身臭汗味。”小瞎子拨开野草在水洼边蹲下，心里还猜想着“曲折的油狼”。“把浑身都洗洗。你那样儿准象个小叫花子。”“那你不就是个老叫花子了？”小瞎子把手按在水里，嘻嘻的笑。老瞎子也笑，双手捧起水来往脸上泼。“可咱们不是叫花子，咱们有手艺。”“这地方咱们好象来过。”小瞎子侧耳听着四周的动静。“可你的心思总不在学艺上。你这小子心太野。老人的话你从不着耳听。”“咱们准是来过这儿。”“别打岔！你那三弦子弹的还差着远呢。咱这命就在几根琴弦上，我师父当年就这么跟我说。”泉水清凉凉的。小瞎子又哥哥妹妹的哼起来。老瞎子挺来气：“我说什么你听见了吗？”“咱这命就在这几根琴弦上，您师父我师爷说的。我就听过八百遍了。您师父还给您留下一张药方，您得弹断一千根琴弦才能去抓那付药，吃了药您就能看见东西了。我听说过一千遍了。”“你信不信？”小瞎子不正面回答，说：“干嘛非得弹断一千根琴弦才能去抓那付药呢？”“那是药引子。机灵鬼儿，吃药得有药引子！”“一千根断了的琴弦还不好弄？”小瞎子忍不住嗤嗤地笑。“笑什么笑！你以为你懂得多少事？得真正是一根一根弹断了的才成。”小瞎子不敢吱声了，听出师父又要动气。每回就是这样，师父 容不得对这件事有怀疑。老瞎子也没再作声，显得有些激动，双手搭在膝盖上，两颗头一样的眼珠结着苍天，象是一根一根地回忆着那 些弹断的琴弦。盼了多少年了呀，老瞎子想，盼了五十年了！五十年中翻了多少架山，走了多少里路哇。挨了多少回晒，挨了多少回冻，心里受了多少委屈呀。一晚上一晚上地弹，心里总记着，得真正是一根一根尽心地弹断了才成。现在快盼到了，绝出不了这个夏天了。 老瞎子知道 自己又没什么 能要命的病，活过这个夏天一点不成问题。“我比我师父可运气多了，” 他说，“我师父到了儿没能睁开眼睛看一回。”“咳！我知道这地方是哪儿了！”小瞎子忽然喊起来。老瞎子这才动子动，抓起自己 的琴来摇了摇，叠好的纸片碰在蛇皮上发出细微的响声，那张药方就在琴槽里。“师父，这儿不是野羊岭吗？”小瞎子问。老瞎子没搭理他，听出这小子又不安稳了。“前头就是野羊坳，是不是，师父？”“小子，过来给我擦擦背。”老瞎子说，把弓一样的脊背弯给他。“是不是野羊坳，师父 ？”“是！干什么？你别又闹猫似的。”小瞎子的心扑通扑通跳，老老实实给师父擦背。老瞎子觉出他擦得很有劲。“野羊坳怎么了？你别又叫驴似的会闻味儿。”小瞎子心虚，不吭声，不让自己显出兴奋。“又想什么呢？别当我不知道你这心思。”“又怎么了，我？”“怎么了你？上回你在这儿疯得不够？那妮子是什么好货！”老瞎子心想，也许不该再带他到野羊坳来。可是野羊坳来。可是野羊坳是个大村子，年年在这儿生意都好，能说上半个多月。老瞎子恨不能立刻弹断最后几根琴弦。小瞎子嘴上嘟嘟囔囔的心却飘飘的，想着野羊坳里那个尖声细气的小妮子。“听我一句话，不害你。”老瞎子说，“那号事靠不住。”“什么事？”“少跟我贫嘴。你明白我说的什么事。”“我就没听您说过，什么事靠得住。”小瞎子又偷偷地笑。老瞎子没理他，骨头一样的眼珠又对着苍天。那儿，太阳正变成一汪血。两面脊背和山是一样的黄褐色。一座已经老了，嶙峋瘦骨象是山根下裸露的基石。另一座正年青。老瞎子七十岁，小瞎子才十七。小瞎子十四岁上父亲把他送到老瞎子这儿来，这是让他学说书，这辈子好有个本事，将来可以独自在世上活下去。老瞎子说书已经说了五十多年。这一片偏僻荒凉的大山里的人们都知道他：头发一天天变白，背一天天变驼，年年月月背一三弦琴满世界走，逢上有愿出钱的地方就动琴弦唱一晚上，给寂寞的山村带来欢乐。开头常是这么几句：“自从盘古分天地，三皇五帝到如今，有道君王害黎民。轻轻弹响三弦琴，慢慢稍停把歌论，歌有三千七百本，不知哪本动人心。”于是听书的众人喊起来，老的要听董永卖身葬父，小的要听武二郎夜走蜈蚣岭，女人们想听秦得莲。这是老瞎子最知足的一刻，身上的疲劳和心里的孤静全忘却，不慌不忙地喝几口水，待众人的吵嚷声鼎沸，便把琴弦一阵紧拨，唱到：“今日不把别人唱，单表公子小罗成。”或者：“茶也喝来烟也吸，唱一回哭倒长城的孟姜女。”满场立刻鸦雀无声，老瞎子也全心沉到自己所说的书中去。他会的老书数不尽。他还有一个电匣子， 据说是花了大价钱从一个山外人手里买来，为的是学些新词儿，编些新曲儿。其实山里人倒太在乎他说什么唱什么。人人都称赞他那 三弦子弹得讲究，轻轻漫漫的，飘飘洒洒的，疯颠狂放的，那里头有天上的日月，有地上的生灵。老瞎子的嗓子能学出世上所有的声音。男人、女人、刮风下雨、兽啼禽鸣。不知道他脑子里能呈现出什么景象，他一落生就瞎了眼睛，从没过这个世界。小瞎子可以算见过世界，但只有三年，那时还不懂事。他对说书和弹琴并无多少兴趣，父亲把他送来的时候费尽了唇舌，好说歹说连哄带骗，最后不如说是那个电匣子把他留住。他抱着电匣子听得入神，甚至发觉父亲以时候离去。这只神奇的匣子永远令他着迷，遥远的地方和稀奇古怪的事物使他幻想不绝，凭着三年朦胧的记忆，补充着万物的色彩和形象。譬如海，匣子里说蓝天就象大海，他记得蓝天，于是想象出满天排开的水锅。再譬如漂亮的姑娘，匣子里说就象盛开的花朵，他实在不相信会是那样，母亲的灵柩被抬到远山上去的时候，路上正开遍着野花，他永远记得却永远不愿意去想。但他愿意想姑娘，越来越愿意想；尤其是野羊坳的那个尖声细气的小妮子，总让他心里荡起波澜，直到有一回匣子里唱道 ，“姑娘的眼睛就象太阳”，这下他才找到了一个贴切的形象，想起母亲在红透的夕阳中向他走来的样子。其实人人都是根据自己的所知猜测着无穷的未知，以自己的感情勾画出世界。每个人的世界就都不同。也总有一些东西小瞎子无从想象，譬如“曲折的油狼”。这天晚上，小瞎子跟着师父在野羊坳说书。又听见那小妮子站在离他不远处尖声细气地说笑。书正说到紧要处――“罗成回马再交战，大胆苏烈又兴兵。苏烈大刀如流水，罗成长枪似腾云，好似海中龙吊宝，犹如深山虎争林。又战七日并牙夜，罗成清茶无点唇……”老瞎子把琴弹得如雨骤风疾，字字句句唱得铿锵，小瞎子却心猿意马，手底下早乱了套数……野羊岭上有一座小庙，离野羊坳村二里地，师徒二人就在这里住下。石头砌的院墙已经残断不全，几间小殿堂也歪斜欲倾百孔千疮，唯正中一间尚可遮蔽风雨，大约是因为这一间中毕竟还供奉着神灵。丰尊泥像早脱尽了尘世的彩饰，还一身黄土本色返朴归真了，认不出是佛是道。院里院外、房顶墙头都长满荒藤野草，蓊蓊郁郁倒有生气。老瞎子每日到野羊坳说书都住在这儿。散了书已经不早，老瞎子在下殿里安顿行李，小瞎子在侧殿的檐下生火烧水。去年砌下的灶火稍加修整就可以用。小瞎子蹶着屁股吹火，柴草不干呛得他满院里转着圈咳嗽。老瞎子在正殿里数叨他：“我看你能干好什么 。”“柴湿嘛。”“我没说这事。我说的是你的琴，今儿晚上的琴你弹成了什么。”小瞎子不敢接这话茬，吸足了几口气又跪到灶火前去，鼓着腮帮子一通猛吹。“你要是不想干这行，就趁早给你爹捎信把你领回去。老这么闹猫闹狗的可不行，要闹回家闹去。”小瞎子咳嗽从灶火边跳开，几步蹿到院子另一头，呼嗤呼嗤大喘气，嘴里一边骂。“说什么呢？”“我骂这火。”“有你那么吹火的？”“那怎么吹？”“怎么吹？哼，”老瞎子顿了顿，又说，“你就当这灶火是那妮子的脸！”小瞎子又不敢搭腔了， 跪到灶火前去再吹，心想：真的，不知道兰秀儿的脸什么样。那个尖声细气的小妮子叫兰秀儿。“那 要是妮子的脸，我看你不用教也会吹。”老瞎子说。小瞎子笑起来，越笑越咳嗽。“笑什么笑！”“您吹过妮子的脸？”老瞎子一时语塞。小瞎子笑得坐在地上。“日他妈。”老瞎子骂道，笑笑，然后变了脸色，再不言语。灶膛里腾的一声，火旺起来。小瞎子再去添柴，一心想着兰秀儿。才散了书的那会儿，兰秀儿挤到他跟前来小声说：“哎，上回你答应我什么来？”师父就在旁边，他没敢吭声。人群挤来挤去，一会儿又把兰秀儿挤到他身边。“噫，上回吃人家的煮鸡蛋倒白吃了？”兰秀儿说，声音比上回大。这时候师父正忙着跟几个老汉拉话。他赶紧说：“嘘――，我记着呢。”兰秀儿又把声音压低：“你答应给我听电匣子你还没给我听。”“嘘――我记着呢。”幸亏那会儿人声嘈杂。正殿里好半天没有动静。之后，琴声响了，老瞎子又上好了一根新弦，他本来应该高兴的，来野羊坳头一晚 就又弹断一根琴弦，可是那琴声却低沉、零乱。小瞎子渐渐听出琴声不对，在院里喊：“水开了，师父。”没有回答。琴声一阵紧似一阵了。小瞎子端了一盆热 水进来。放在师父跟前，故意嘻嘻笑着说：“您今儿晚还想弹断一根是怎么着？”老瞎了没听见，这会儿他自己的往事都在心中。琴声烦躁不安，象是年年旷野里的风雨，象是日夜山谷中的溪流，象是奔奔忙忙不知所归的脚步声。小瞎子有点害怕了：师父很久不这样了，师父一这样就要犯病，头疼、心口疼、浑身疼，会几个月爬 不起炕来。“师父，您先洗脚吧。”琴声不停。“师父，您该洗脚了。”小瞎子的声音发抖。琴声不停。“师父！”琴声戛然而止，老瞎子叹了口气。小瞎子松了口 气。老瞎子洗脚，小瞎子乖乖地坐在他身身边。“睡去吧，”老瞎子说，“今儿格够累的了。”“您呢？”“你先睡，我得好好泡泡脚。人上了岁数毛病多。”老瞎子故意说得轻松。“我等您 一块儿睡 。”山深夜静，有一点风，墙头的草叶子响。夜猫子在远处哀哀地叫。听得见野羊坳里偶尔有几声狗吠，又引得孩子哭。月亮升起来，白光透过残损的窗棂进了殿堂，照见两个瞎子和三尊神像。“等我干嘛，时候不早了。”“你甭担心我，我怎么也不怎么，”老瞎子又说。“听见没有，小子？”小瞎子到底年轻，已经睡着。老瞎子推推他让他躺好，他嘴里咕囔了几句倒头睡去。老瞎子给他盖被子时，从那身日渐发育的筋肉上觉出，这孩子到了要想那 些事的年龄，非得有一段苦日子过不可了。唉，这事谁也替不了谁。老瞎子再把琴抱在怀里，摩挲着根根绷紧的琴弦。心里使劲念叨：又断了一根了，又断了一根了。再摇摇琴槽，有轻微的纸和蛇皮的磨擦声，唯独这事能为他排忧解烦。一辈子的愿望。小瞎子作了一个好梦。醒来吓了一跳，鸡已经叫了。他一骨碌爬起来听听，师父下睡得香，心说还好。他摸到那个大挎包，悄悄地掏出电匣子，蹑手蹑脚出了门。往野羊坳方向走了一会儿，他才觉 出不对头，鸡叫声渐渐停歇，野羊坳里还是静静的没有人声。他愣了一会儿，鸡才叫头遍吗？灵机一动扭开电匣子。电匣子里也是静悄悄。现在是半夜。他半夜里听过匣子，什么都没有。这匣子对他来说还是个表。只要扭开一听，便知道是几点钟，什么时候有什么节目都是一定的。小瞎子回到庙里，老瞎子正翻身。“干嘛哪？”“撒尿去了。”小瞎子说。一上午，师父逼着他练琴。直到响午饭后，小瞎子才瞅机会溜出庙来，溜进野羊坳。鸡也在树荫下打盹，猪也在墙根下说着梦话，太阳又热得凶，村子里很安静。小瞎子踩着磨盘，扒着兰秀儿家的墙头轻声喊：“兰秀儿――兰秀儿――”屋里传出雷似的鼾声。他犹豫了片刻，把声音稍稍抬高：“兰秀儿――！兰秀儿！”狗叫起来。屋里鼾声停了，一个闷声闷气的声音问：“谁呀？”小瞎子不敢回答，把脑袋从墙 头上缩下来。屋里吧唧了一阵嘴，又响起鼾声。他叹口气，从靡盘上下来怏怏地往回走。忽听见身后嘎吱一声院门响，随即一阵细碎的脚步声向他跑来。“猜是谁？”尖声细气。小瞎子的眼睛被一双柔软的小手捂上了。――这才多余呢。兰秀儿不到十五岁，认真说还是孩子。“兰秀儿！”“电匣子拿来没？”小瞎子掀开衣襟，匣子挂在腰上。“嘘――，别在这儿，找个没人的地方听去。”“咋啦？”“回头招好些人。”“咋啦？”“那么多人听，费电。”两个人东拐西弯，来到山背后那 眼小泉边。小瞎子忽然 想起件事，问兰秀儿：“你见过曲折的油狼吗？”“啥？”“曲折的油狼。”“曲折的油狼？”“知道吗？”“你知道？”“当然。还有绿色的长椅。就一把椅子。”“椅子谁不知道。”“那曲折的油狼呢？”兰秀儿摇摇头，有点崇拜小瞎子了。小瞎子这才郑重其事地扭开电匣子，一支欢快的乐曲在山沟里飘荡。地方又凉快又没有人来打扰。“这是‘步步高’。”小瞎子说，跳着哼。一会儿又换了支曲子，叫“旱天雷”，小瞎子还能跟着哼。兰秀儿觉得很惭愧。“这曲子也叫‘和尚思妻’。”兰秀儿笑起来：瞎骗人！““你信不信？”“不信。”“爱信不信。这匣子里说的古怪事多啦。”小瞎子玩着凉凉的泉水，想了一会儿。“你知道什么叫接吻吗？”“你说什么叫？”这回轮到小瞎子笑，光笑不答。兰秀儿明白准不是好话，红着脸不再问。音乐播完了一个女人说，“现在是讲卫生节目。”“啥？”兰秀儿没听清。“讲卫生。”“是什么？”“嗯――，你头发上有虱子吗？”“去――，别动！”小瞎子赶忙缩回手来，赶忙解释：“要有就是不讲卫生。”“我才没有。”兰秀儿抓抓 头，觉得有些刺立，“噫――瞧你自个儿吧！”兰秀儿一把搬过小瞎子的头。“看我捉几个大的。”这时候听见老瞎子在半山上喊：“小子，还不给我回来！该做饭了，吃罢饭还得去说书！”他已经站在那儿听了好一会儿了。野羊坳里已经昏暗，羊叫、驴叫、狗叫、孩子们叫， 处处起了炊烟，野羊岭上还有一线残阳，小庙正在那淡薄的光中，没有声响。小瞎子又蹶着屁股烧火。老瞎子坐在一旁淘米，凭着听觉他能把米中的砂子捡出来。“今天的柴挺干。”小瞎了说。“嗯。”“还是焖饭？”“嗯。”小瞎子这会儿精神百倍，很想找些话说，但是知道师父的气还没消，心说还是少找骂。两个人默默地干着自己的事，又默默地一块儿把饭做熟。岭上也没了阳光。小瞎子盛了一碗小米饭 ，先给师父：“您吃吧。”声音怯怯的，无比驯顺。老瞎子终于开了腔：“小子，你听我一句行不？”“嗯 。”小瞎子往嘴里扒拉饭，回答得含糊。“你要是不愿意听，我就不说。”“谁说不愿意听了？我说‘嗯’！”“我是过来人，总比你知道的多。”小瞎子闷头扒拉饭。“我经过那 号事。”“什么事？”“又跟我贫嘴！”老瞎子把筷子往灶台上一摔。“兰秀儿光是想听听电匣子。我们光是一块儿听电匣子来。”“还有呢？”“没有了。”“没有了？”“我还问她见过曲折的油狼。”“我没问你这个。”“后来，后来，”小瞎子不那么气壮了，“不知怎么一下就说起了虱子……”“还有呢？”“没了，真没了！”两个人又默默地吃饭 。老瞎子带了这徒弟好几年，知道这孩子不会撒谎，这孩子最让人放心的地方就是诚实、厚道。“听我一句话，保准对你没坏处。以后离她远点好。早年你师爷这么跟我说，我也不相信……”“师爷？说兰秀儿？”“什么兰秀儿，那 会儿还没她呢，那会儿有你们呢……”老瞎子阴郁的脸又转向暮色浓重的天际，骨头一样白色的眼珠不住地转动，不知道在那儿他想能“看”见什么。许久，小瞎子说：“今儿晚上您多半又能弹断一根琴弦，”想让师父高兴些。这天晚上师徒在野羊坳说书。“上回说到罗成死，三魂七魄赴幽冥，听歌君子莫嘈 嚷，列位蝗我道下文。罗成阴魂出地府，一阵旋风就起身，旋风一阵来得快，长安不远面前存……”老瞎子的琴声也乱，小瞎子的琴声也乱，小瞎子回忆着那比柔软的小手捂在自己脸上的感觉，还有自己 的头被兰秀儿搬过去的滋味。老瞎子想起的事情更多……夜里老瞎子翻来覆去睡不安稳，多少往事在他耳边喧器，在他心头动荡，身体里仿佛有什么东西要爆炸。坏了，要犯病，他想。头昏，胸口憋闷，浑身紧巴巴的难受。他坐起来，对自己叨咕：“可别犯病，一犯病今年不甭想弹够那 些琴弦了。”他又摸到琴。要能叮叮当当随心所欲地疯弹一阵，心头的忧伤或许就能平息耳边的往事或许 就会消散。可是小瞎子正睡得香甜。他只好再全力去想那 张药方和琴弦：还剩下几根，还只剩最后几根了。那时就可以去抓药了，然后就能看见这个世界――他无数次爬过的山，无数次走过的路，无数次感到过她的温暖和炽热的太阳 ，无数次梦想着的蓝天和月亮和星星……还有呢？还有什么？他朦胧中所盼望的东西似乎比这要多得多……夜风在山里游荡。猫头鹰又在凄哀地叫。不过现在他老了，无论如何没年活头了，失去的，已经永远失去了，他象是刚刚意识到这一点。七十年中所受的全部辛苦就为了最后能看一眼世界，这值得吗？他问自己。小瞎子在梦里笑，在梦里说：“那是一把椅子，兰秀儿……”老瞎子静静地坐着，静静地坐着的还有那三尊分不清是佛是道的泥像。鸡叫头遍的时候老瞎子决定，天一亮就带这孩子离开野羊坳。否则这孩子受不了，他自己也受不了。兰秀儿不坏，可这事会怎么结局，老瞎子比谁都“看”得清楚。鸡叫二遍，老瞎子开始收拾行李。可是一早起来小瞎子病了，肚子疼，随即又发烧。老瞎子只好把行期推迟。一连好几天，老瞎子无论是烧火、淘米、捡柴，还是给小瞎子挖药、煎药，心里总在说：“值得，当然值得。”要是不这么反反复复对自己说身上的力气几乎就要垮掉。“我非要最后看一眼不可。”“要不怎么着？就这么死了去？”“再说就只剩下最后几根了。”后面三句都是理由。老瞎子又冷静下来，天天晚还到野羊坳去说书。这一下小瞎子倒来了福气。每天晚上师父到岭下去了，兰秀儿就猫似的轻轻跳进庙里来听匣子。兰秀儿还带来熟的鸡蛋，条件是得让她亲手去扭那匣子的开关。“往哪边扭？”“往右”“扭不动。”“往右，笨货，不知道哪边是右哇？”？“咔哒”一下，无论是什么便响起来，无论是什么俩人都爱听。又过了几天，老瞎子又弹断了三根弦。这一晚，老瞎子在野羊坳里自弹自唱：“不表罗成投胎事，又唱秦王李世民。秦王一听双泪流，可怜 爱卿丧残身，你死一乘风破浪 打紧，缺少扶朝上将军……”野羊坳上的小庙里这时更热闹。电匣子的音量开得挺大，又是孩子哭，又是大人喊，轰隆隆地又响炮，嘀嘀哒吹地又吹号。月光照进正殿，小瞎子躺着啃鸡蛋，兰秀儿坐在他旁边。两个人都听得兴奋，时而大笑，时而稀里糊涂莫名其妙。“这匣子你师父哪卖来？”“从一个山外头的人手里。”“你们到山外头去过？”兰秀儿问。“没。我早晚要去一回就是，坐坐火车。”“火车？”“火车你也不知道？笨货。”“噢，知道知道，冒烟哩是不是？”过了一会儿兰秀儿又说：“保不准我就得到山外头去。”语调有些惶。“是吗？”小瞎子一挺坐起来，“那你到底瞧瞧曲折的油狼是什么。”“你说是不是山外头的人都有电匣子？”“谁知道。我说你听清楚没有？曲、折、的、油、狼，这东西就在山外头。”“那我得跟他们要一个电匣子。”兰秀儿自言自语地想心事。“要一个？”小瞎子笑两声，然后住气，然后大笑：“你干嘛不要俩？你可真本事大。你知道这匣子几千块钱一个？把你卖了吧，怕也换不来。”兰秀儿心里正委屈，一把揪住小瞎子的耳朵使劲拧，骂道：“好你死瞎子。”两个人在堂殿里扭打起来。三尊泥像袖手旁观帮不上忙，两个年青的正在发育的身体碰撞在一起 ，纠缠在一起，一个把一个压进身下，一会儿又颠倒过来，骂声变成笑声。匣子在一边唱。打了好一阵子，两个人都累得住手，心怦怦跳，躺着喘气，不言声儿，谁却也不愿意再拉开距离，兰秀儿呼出的气吹在小瞎子的脸上，小瞎子感到了诱惑，并且想起那天吹火时师父说的话，就往兰秀儿脸上吹气。兰秀儿并不躲。“嘿，”小瞎子小声说，“你知道接吻是什么了吗？”“是什么？”兰秀儿的声音也小。小瞎子对着兰秀儿的耳朵告诉她。兰秀儿不说话。老瞎子回来之前，他们试着亲了嘴儿，滋味真不坏……就是这天晚上，老瞎子弹断了最后两根琴弦。两根弦一齐断了。他没料到。他几乎是连跑带爬地上了野羊岭，回到小庙里。小瞎子吓了一跳：“怎么了，师父？”老瞎子喘吁吁地坐在那儿，说不出话。小瞎子有些犯嘀咕：莫非是他和兰秀儿干的事让师父知道了？老瞎子这才相信一切都是值得的。一辈子的辛苦是值得的。能看一回，好好看一回，怎么都是值得的。“小子，明天我就去抓药。”“明天？”“明天。”“又断了一根了？”“两根。两根都断了。”老瞎子把那 两根弦卸下来，放在手里揉搓了一会儿，然后把他们并到另外的九百九十八根去，绑成一捆。“明天就走？”“天一亮就动身。”小瞎子心里一阵发凉。老瞎子开始剥琴槽上的蛇皮。“可我的病还没好利索。”小瞎子小声叨咕。“噢，我想过了，你就先留在这儿，我用不了十天就回来。”小瞎子喜出望外。“你一个人行不？”“行！”小瞎子紧忙说。老瞎子早忘了兰秀儿的事。“吃的、喝的、烧的全有。你要是病好利索了，也该学着自个儿出去说回书。行吗？”“行。”小瞎子觉得有点对不住师父。蛇皮剥开了，老瞎子人琴槽中取出一张叠得方方正正的纸条。他想起这药方进琴槽时，自己才二十岁，便觉得浑身上下都好象冷。小瞎子也把那药方放在手里摸了一会儿，也有了几分肃穆。“你师爷一辈子才冤呢。”“他弹断了多少根？”“他本来能弹够一千根，可他记成了八百。要不然他能弹断一千根。”天不亮老瞎子就上路了。他说最多十天就回来。谁也没想到他竟去了那么久。老瞎子回到羊坳时已经是冬天。漫 天大雪，灰暗的天空连接着白色的群山。没有声息，处处也没有生气，空旷而沉寂。所以老瞎子那顶发了黑的草帽就尤其躜动得显著。他蹒蹒跚跚地爬上野羊岭，庙院中衰草瑟瑟，窜出一只狐狸，仓惶逃远。村里人告诉他，小瞎子已经走了些日子。“我告诉他等我回来。”“不知道他干嘛就走了。”“他没说去哪儿，留下什么话没？”“他说让您甭找他。”“什么时候走的？”人们想了好久，都说是在兰秀儿嫁到山外去的那天。老瞎子心里便一切全明白。众人劝老瞎子留下来，这么冰天雪地的上哪去？不如在野羊坳说一冬天书。 老瞎子指指他的琴，人们见琴柄上空荡荡已经没了琴弦。老瞎子面容也憔悴，呼吸也孱弱，嗓音也沙哑了，完全变了个人。他说得去找他的徒弟。若不是还想着他的徒弟，老瞎子就回不到野羊坳。那张他保存了五十年的药方原来是一张无字的白纸。他不信，请了多少识字而又诚实的人帮他看，人人都说那果真是一张无字的白纸。老瞎子在药铺前的台阶上坐了一会儿，他以为是一会儿，其实已经几天几夜，骨头一样的眼珠在询问苍天，脸色也变成骨头一样的苍白。有人以为他是疯了，安慰他，劝他。老瞎子苦笑：七十岁了再疯还有什么意思？他只是再不想动弹，吸引着他活下去、走下去、唱下去的东西骤然间消失干净。就象一根不能拉紧的琴弦，再难弹出悦耳的曲子。老瞎子的心弦断了，准确地说，是有一端空无所系了。一根琴弦需要两个点才能拉紧。心弦也要两 个点――一头是追求，一头是目的――你才能在中间这紧绷绷的过程上弹响心曲。现在发现那目的原来是空的。老瞎子在一个小客店里住了很久，觉得身体里的一切都在熄灭。他整天躺在炕上，不弹也不唱，一天天迅速地衰老。直到花光了身上所有的钱，直到忽然想起他的徒弟，他知道自己的死期将至，可那孩子在等他回去。茫茫雪野，皑皑群山，在地之间躜动着一个黑点。走近时，老瞎子的身身影弯得如一痤桥。他去找他的徒弟。他知道那孩子目前的心情、处境。他想自己先得振作起来，但是不行，前面明明没有了目标。他一路走，便怀恋起过去的日子，才知道以往那些奔奔忙忙兴致勃勃的翻山、走路、弹琴，乃至心焦、忧虑都是多么欢乐！那时有个东西把心弦扯紧，虽然那东西原是虚设。老瞎妇想起他师父临终时的情景。他师父把那张自己没用上的药方封进他的琴槽。“您别死，再活几年，您就能睁眼看一回了。”说这话时他还是个孩子。他师父久久不言语，最后说：“记住，人的命就象这琴弦，拉紧了才能弹好，弹好了就够了。”……不错，那意思就是说：目的本来没有。不错，他的一辈子都被那虚设的目的拉紧，于是生活中叮叮当当才有了生气。重要的是从那绷紧的过程中得到欢乐，老瞎子知道怎么对自己的徒弟说了。可是他又想：能把一切都告诉小瞎子吗？老瞎子又试着振作起来，可还是不行，总摆脱不掉那无字的白纸……在深山里，老瞎子找到了小瞎子。小瞎子正跌倒在雪地里，一动不动，想那么等死。老瞎子懂得那绝不是装出来的悲衰。老瞎子把他拖进一个山洞，他已无力反抗。老瞎子捡了些柴，打起一堆火。小瞎子渐渐有了哭声。老瞎子放了心，任他尽情尽意地哭 。只要还能哭就还有救，只要还能哭就有哭够的时候。小瞎子哭了几天几夜，老瞎子就那么一声不吭地守着。火光和哭声惊动了野免子、山鸡、野羊和狐狸和鹞鹰……终于小瞎子说话了：“干嘛咱们是瞎子！”“就因为咱们是瞎子。”老瞎子回答。终于小瞎子又说：“我想睁开眼看看，师父，我想睁开眼看看！哪怕就看一回。”“你真那么想吗？”“真想，真想――”老瞎子把篝火拨得更旺些。雪停了。铅灰色的天空中，太阳象一面闪光的小镜子，鹞鹰在平稳地滑翔。“那就弹你的琴弦，”老瞎子说，“一根一根尽力地弹吧。”“师父，您的药抓来了？”小瞎子如梦方醒。“记住，得真正是弹断的才成。”“您已经看见了吗？师父，您现在看得见了？”小瞎子挣扎着起来，伸手去摸师父的眼窝。老瞎子把他的手抓住。“记住，得弹断一千二百根。“一千二？”“把你的琴给我，我把这药方给你封在琴槽里。”老瞎子现在才懂了师父当年对他说的话――你的命就在这琴弦上。目的虽是虚设的，可非得有不行，不然琴弦怎么拉紧，拉不紧就弹不响。“怎么是一千二，师父？”“是一千二。我没弹够，我记成了一千。”老瞎子想：这孩子再怎么弹吧，还能弹断一千二百根？永远扯紧欢跳的琴弦，不必去看那无字的白纸……这地方偏僻荒凉，群山不断。荒草丛中随时会飞起一对山鸡，跳出一只野免、狐狸，或者其它小野兽。山谷中鹞鹰在盘旋。现在让我们回到开始：莽莽苍苍的群山之中走着两个瞎子，一老一少，一前一后，两顶发了黑的草帽起伏躜动，匆匆忙忙，象是随着一条不安静的河水在漂流。无所谓从哪儿来、到哪儿去，也无所谓谁是谁……","categories":[{"name":"诗和小说以及文章","slug":"诗和小说以及文章","permalink":"http://Scofieldsu.github.io/categories/诗和小说以及文章/"}],"tags":[{"name":"The_Life_You_Want","slug":"The-Life-You-Want","permalink":"http://Scofieldsu.github.io/tags/The-Life-You-Want/"}]},{"title":"致橡树","slug":"致橡树","date":"2016-05-11T16:23:21.000Z","updated":"2018-01-14T18:00:36.380Z","comments":true,"path":"2016/05/12/致橡树/","link":"","permalink":"http://Scofieldsu.github.io/2016/05/12/致橡树/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071致橡树 --舒婷 我如果爱你—— 绝不像攀援的凌霄花， 借你的高枝炫耀自己； 我如果爱你—— 绝不学痴情的鸟儿 为绿荫重复单调的歌曲； 也不止像泉源 长年送来清凉的慰藉； 也不止像险峰 增加你的高度，衬托你的威仪。 甚至日光。 甚至春雨。 不，这些都还不够！ 我必须是你近旁的一株木棉， 作为树的形象和你站在一起。 根，紧握在地下 叶，相触在云里。 每一阵风吹过 我们都互相致意， 但没有人 听懂我们的言语。 你有你的铜枝铁干， 像刀、像剑 也像戟； 我有我红硕的花朵 像沉重的叹息， 又像英勇的火炬。 我们分担寒潮、风雷、霹雳； 我们共享雾霭、流岚、虹霓。 仿佛永远分离， 却又终身相依。 这才是伟大的爱情， 坚贞就在这里：不仅爱你伟岸的身躯， 也爱你坚持的位置，脚下的土地。","categories":[{"name":"诗和小说以及文章","slug":"诗和小说以及文章","permalink":"http://Scofieldsu.github.io/categories/诗和小说以及文章/"}],"tags":[{"name":"The_Life_You_Want","slug":"The-Life-You-Want","permalink":"http://Scofieldsu.github.io/tags/The-Life-You-Want/"}]},{"title":"一颗开花的树","slug":"一颗开花的树","date":"2016-05-08T15:02:10.000Z","updated":"2018-01-14T17:59:48.040Z","comments":true,"path":"2016/05/08/一颗开花的树/","link":"","permalink":"http://Scofieldsu.github.io/2016/05/08/一颗开花的树/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435一棵开花的树 -- 席慕容如何让你遇见我在我最美丽的时刻为这我已在佛前求了五百年求它让我们结一段尘缘佛于是把我化作一棵树长在你必经的路旁阳光下慎重地开满了花朵朵都是我前世的盼望当你走近请你细听颤抖的叶是我等待的热情而你终于无视地走过在你身后落了一地的朋友啊 那不是花瓣是我凋零的心","categories":[{"name":"诗和小说以及文章","slug":"诗和小说以及文章","permalink":"http://Scofieldsu.github.io/categories/诗和小说以及文章/"}],"tags":[{"name":"The_Life_You_Want","slug":"The-Life-You-Want","permalink":"http://Scofieldsu.github.io/tags/The-Life-You-Want/"}]},{"title":"socket(1)","slug":"socket(1)","date":"2016-04-28T12:49:56.000Z","updated":"2018-01-14T09:53:31.433Z","comments":true,"path":"2016/04/28/socket(1)/","link":"","permalink":"http://Scofieldsu.github.io/2016/04/28/socket(1)/","excerpt":"","text":"网络编程 创建通信端点，它使服务器监听请求，一旦一个通信端点已经建立，监听服务可以进入无线循环中，等待客户端的连接并响应他们的请求。 套接字最初始为同一主机上的应用程序所创建，使得主机上运行的一个程序与另一个运行的程序进行通信，这就是所谓的进程间的通信。 有两种类型的套接字：基于文件的 和面向网络的 基于文件的：AF_UNIX 基于网络的：AF_INET python2.5引入了对特殊类型的linux套接字支持，AF_NETLINK python2.6中支持透明的进程间通信（TIPC）协议 AF_TIPC 有效端口范围0~65535 （小于1024的为系统预留） 面向连接的套接字 （虚拟电路或者流套接字）：提供序列化的、可靠的不重复的数据交付，没有记录边界。传输控制协议（TCP）实现，使用SOCK_STREAM作为套接字类型。 面向无连接的套接字（数据报类型的套接字）：用户数据报协议（UDP）实现，使用SOCK_DGRAM作为套接字类型。 套接字对象方法 服务器端套接字函数 socket类型 描述 s.bind() 绑定地址（主机号 端口号对）到套接字 s.listen() 开始TCP监听 s.accept() 被动接受TCP客户端连接，（阻塞式）等待连续的到来 客户端套接字函数 socket类型 描述 s.connect() 主动初始化TCP服务器连接 s.connect_ex() connect()函数扩展版本，出错时返回出错码而不是跑出异常 公共用途的套接字函数 socket类型 描述 s.recv() 接受TCP数据 s.send() 发送TCP数据 s.sendall() 完整发送TCP数据 s.recvfrom() 接受UDP数据 s.sendto() 发送UDP数据 s.getpeername() 连接到当前套接字的远端地址（TCP连接） s.getsockname() 获取当前套接字的地址 s.getsockopt() 返回指定套接字的参数 s.setsockopt() 设置指定套接字的参数 s.close() 关闭套接字 面向模块的套接字函数 socket类型 描述 s.setblocking() 设置套接字的阻塞与非阻塞模式 s.settimeout() 设置阻塞套接字操作的超时时间 s.gettimeout() 得到阻塞套接字操作的超时时间 面向文件的套接字函数 socket类型 描述 s.fileno() 套接字的文件描述符 s.makefile() 创建一个与套接字关联的文件对象 创建TCP服务器的伪代码： 1234567891011服务器 tcpSerSock.py 核心操作如下： ss = socket() # 创建服务器套接字 ss.bind() # 地址绑定到套接字上 ss.listen() # 监听连接 inf_loop: # 服务器无限循环 cs = ss.accept() # 接受客户端连接 阻塞式:程序连接之前处于挂起状态 comm_loop: # 通信循环 cs.recv()/cs.send() # 对话 接受与发送数据 cs.close() # 关闭客户端套接字 ss.close() # 关闭服务器套接字 (可选) 创建tcp服务器 1234567891011121314151617181920212223242526272829303132# -*- coding: utf-8 -*-from socket import *from time import ctimeHOST = 'localhost' #主机名PORT = 21567 #端口号BUFSIZE = 1024 #缓冲区大小1KADDR = (HOST,PORT)tcpSerSock = socket(AF_INET, SOCK_STREAM)tcpSerSock.bind(ADDR) #绑定地址到套接字tcpSerSock.listen(5) #监听 最多同时5个连接进来while True: #无限循环等待连接到来 try: print 'Waiting for connection ....' tcpCliSock, addr = tcpSerSock.accept() #被动接受客户端连接 print u'Connected client from : ', addr while True: data = tcpCliSock.recv(BUFSIZE) #接受数据 if not data: break else: print 'Client: ',data tcpCliSock.send('[%s] %s' %(ctime(),data)) #时间戳 except Exception,e: print 'Error: ',etcpSerSock.close() #关闭服务器 创建tcp客户端的伪代码 1234567客户端 tcpCliSock.py 核心操作如下： cs = socket() # 创建客户端套接字 cs.connect() # 尝试连接服务器 comm_loop: # 通讯循环 cs.send()/cs.recv() # 对话 发送接受数据 cs.close() # 关闭客户端套接字 创建tcp客户端 1234567891011121314151617181920212223242526# -*- coding: utf-8 -*-from socket import *HOST = 'localhost' #主机名PORT = 21567 #端口号 与服务器一致BUFSIZE = 1024 #缓冲区大小1KADDR = (HOST,PORT)tcpCliSock = socket(AF_INET, SOCK_STREAM)tcpCliSock.connect(ADDR) #连接服务器while True: #无限循环等待连接到来 try: data = raw_input('&gt;') if not data: break tcpCliSock.send(data) #发送数据 data = tcpCliSock.recv(BUFSIZE) #接受数据 if not data: break print 'Server: ', data except Exception,e: print 'Error: ',etcpCliSock.close() #关闭客户端 创建udp服务端的伪代码 123456789服务器 udpSerSock.py 核心操作如下： ss = socket() # 创建服务器套接字 ss.bind() # 绑定服务器套接字 inf_loop: # 服务器无限循环 cs = ss.recvfrom()/ss.sendto() # 对话 接受与发送数据 ss.close() # 关闭服务器套接字 创建udp服务端 123456789101112131415161718192021222324# -*- coding: utf-8 -*-from socket import *from time import ctimeHOST = '' #主机名PORT = 21567 #端口号BUFSIZE = 1024 #缓冲区大小1KADDR = (HOST,PORT)udpSerSock = socket(AF_INET, SOCK_DGRAM)udpSerSock.bind(ADDR) #绑定地址到套接字while True: #无限循环等待连接到来 try: print 'Waiting for message ....' data, addr = udpSerSock.recvfrom(BUFSIZE) #接受UDP print 'Get client msg is: ', data udpSerSock.sendto('[%s] %s' %(ctime(),data), addr) #发送UDP print 'Received from and returned to: ',addr except Exception,e: print 'Error: ',eudpSerSock.close() #关闭服务器 创建udp客户端的伪代码 1234567客户端 udpCliSock.py 核心操作如下： cs = socket() # 创建客户端套接字 inf_loop: # 服务器无限循环 cs.sendto()/cs.recvfrom() # 对话 接受与发送数据 cs.close() # 关闭客户端套接字 创建udp客户端 1234567891011121314151617181920212223242526# -*- coding: utf-8 -*-from socket import *HOST = 'localhost' #主机名PORT = 21567 #端口号 与服务器一致BUFSIZE = 1024 #缓冲区大小1KADDR = (HOST,PORT)udpCliSock = socket(AF_INET, SOCK_DGRAM)while True: #无限循环等待连接到来 try: data = raw_input('&gt;') if not data: break udpCliSock.sendto(data, ADDR) #发送数据 data,ADDR = udpCliSock.recvfrom(BUFSIZE) #接受数据 if not data: break print 'Server : ', data except Exception,e: print 'Error: ',eudpCliSock.close() #关闭客户端","categories":[{"name":"python","slug":"python","permalink":"http://Scofieldsu.github.io/categories/python/"}],"tags":[{"name":"socket，tcp，udp","slug":"socket，tcp，udp","permalink":"http://Scofieldsu.github.io/tags/socket，tcp，udp/"}]},{"title":"获取mac地址","slug":"获取mac地址","date":"2015-08-28T08:18:20.000Z","updated":"2018-01-14T09:53:31.415Z","comments":true,"path":"2015/08/28/获取mac地址/","link":"","permalink":"http://Scofieldsu.github.io/2015/08/28/获取mac地址/","excerpt":"","text":"##获取mac地址的比较 方法1 123456789101112131415161718def get_mac(self): sd=os.popen(\"ipconfig/all\").read() lans= sd.split(\"\\r\\n\\r\\n\") lns=[] for i in lans: ln=[str(s).strip() for s in i.split(\"\\r\\n\")] lns.append(ln) dip=socket.gethostbyname(socket.gethostname())#获取主机IP地址 import re mac=\"\"; for i in lns:#获取MAC地址 for j in i: if j.strip().find(dip)!=-1: for m in i: L = re.findall('([0-9,A-F]&#123;2&#125;-[0-9,A-F]&#123;2&#125;-[0-9,A-F]&#123;2&#125;-[0-9,A-F]&#123;2&#125;-[0-9,A-F]&#123;2&#125;-[0-9,A-F]&#123;2&#125;)', m) if L: mac=L[0] return mac 方法2 1234import uuiddef get_mac_address(): mac=uuid.UUID(int = uuid.getnode()).hex[-12:] return \"-\".join([mac[e:e+2] for e in range(0,11,2)]) 当电脑有多个网卡时，例如开启虚拟机，方法2获取的为最后一个网卡的物理地址,故方法1更合理 MAC（Media Access Control或者Medium Access Control）地址，意译为媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。在OSI模型中，第三层网络层负责 IP地址，第二层数据链路层则负责 MAC地址。因此一个主机会有一个MAC地址，而每个网络位置会有一个专属于它的IP地址。 MAC地址是网卡决定的，是固定的。","categories":[{"name":"python","slug":"python","permalink":"http://Scofieldsu.github.io/categories/python/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://Scofieldsu.github.io/tags/mac/"},{"name":"socket","slug":"socket","permalink":"http://Scofieldsu.github.io/tags/socket/"}]},{"title":"网络协议","slug":"网络协议","date":"2015-08-15T15:34:15.000Z","updated":"2018-01-14T18:10:04.134Z","comments":true,"path":"2015/08/15/网络协议/","link":"","permalink":"http://Scofieldsu.github.io/2015/08/15/网络协议/","excerpt":"","text":"OSI：开放式系统互联(open system interconnection),参考模型，不是强制标准。 网络通信分为7层：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。 Tcp/IP：应用层，传输层，internet层，网络访问层。 TCP协议：传输控制协议，Transmission Control Potocol. 建立连接：三次握手SYN 关闭连接：四次挥手FIN 保证连接的可靠： UDP协议：User Diagram Potocol.(可靠性差，性能好) Wireshark工具。","categories":[{"name":"网络相关","slug":"网络相关","permalink":"http://Scofieldsu.github.io/categories/网络相关/"}],"tags":[{"name":"http，tcp，udp","slug":"http，tcp，udp","permalink":"http://Scofieldsu.github.io/tags/http，tcp，udp/"}]},{"title":"python(2):进程vs线程","slug":"python(2)-线程vs进程","date":"2015-08-10T14:01:27.000Z","updated":"2018-01-14T18:06:40.667Z","comments":true,"path":"2015/08/10/python(2)-线程vs进程/","link":"","permalink":"http://Scofieldsu.github.io/2015/08/10/python(2)-线程vs进程/","excerpt":"","text":"实现多任务，设计Master-Worker模式。通常是1个Master，多个worker。 多进程（multiprocessing） 多进程稳定性高，一个子进程崩溃了，不会影响主进程和其他子进程。Apache最早就是采用多进程。 多进程缺点就是创建进程代价大，在Unix/Linux系统下，用123456789101112131415161718192021222324252627282930313233343536373839**多线程（multithreading）**- 多线程效率比多进程高，微软的IIS服务器默认采用多线程。但稳定性不够，致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存。---&lt;!-- more --&gt;### 任务类型：计算密集型和IO密集型。**计算密集型**- 由于主要消耗CPU资源，最好用C语言编写。**IO密集型**- 涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。---### 异步IO- 如果充分利用操作系统提供的异步IO支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型，**Nginx就是支持异步IO的Web服务器**，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。由于系统总的进程数量十分有限，因此操作系统调度非常高效。用异步IO编程模型来实现多任务是一个主要的趋势。对应到Python语言，```单进程的异步编程模型称为协程```，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。---## 多进程```pythonfrom multiprocessing import Processimport os # 子进程要执行的代码def run_proc(name): print &apos;Run child process %s (%s)...&apos; % (name, os.getpid())if __name__==&apos;__main__&apos;: print &apos;Parent process %s.&apos; % os.getpid() p = Process(target=run_proc, args=(&apos;test&apos;,)) print &apos;Process will start.&apos; p.start() p.join() print &apos;Process end. 创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。 join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。 Pool 如果要启动大量的子进程，可以用12345678910111213141516171819202122```pythonfrom multiprocessing import Poolimport os, time, randomdef long_time_task(name): print &apos;Run task %s (%s)...&apos; % (name, os.getpid()) start = time.time() time.sleep(random.random() * 3) end = time.time() print &apos;Task %s runs %0.2f seconds.&apos; % (name, (end - start))if __name__==&apos;__main__&apos;: print &apos;Parent process %s.&apos; % os.getpid() p = Pool() for i in range(5): p.apply_async(long_time_task, args=(i,)) print &apos;Waiting for all subprocesses done...&apos; p.close() p.join() print &apos;All subprocesses done.&apos; 对Pool对象调用join()方法会等待所有子进程执行完毕，调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了。 请注意输出的结果，task 0，1，2，3是立刻执行的，而task 4要等待前面某个task完成后才执行，这是因为Pool的默认大小在我的电脑上是4，因此，最多同时执行4个进程,Pool的默认大小是CPU的核数。 进程间通信 Process之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。Python的multiprocessing模块包装了底层的机制，提供了12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849### 分布式进程优选Process，因为Process更稳定，而且，Process可以分布到多台机器上，而Thread最多只能分布到同一台机器的多个CPU上。Python的multiprocessing模块不但支持多进程，其中managers子模块还支持把多进程分布到多台机器上。一个服务进程可以作为调度者，将任务分布到其他多个进程中，依靠网络通信。由于managers模块封装很好，不必了解网络通信的细节，就可以很容易地编写分布式多进程程序。举个例子：如果我们已经有一个通过Queue通信的多进程程序在同一台机器上运行，现在，由于处理任务的进程任务繁重，希望把发送任务的进程和处理任务的进程分布到两台机器上。怎么用分布式进程实现？原有的Queue可以继续使用，但是，通过managers模块把Queue通过网络暴露出去，就可以让其他机器的进程访问Queue了。我们先看服务进程，服务进程负责启动Queue，把Queue注册到网络上，然后往Queue里面写入任务：```python # taskmanager.pyimport random, time, Queuefrom multiprocessing.managers import BaseManager # 发送任务的队列:task_queue = Queue.Queue() # 接收结果的队列:result_queue = Queue.Queue() # 从BaseManager继承的QueueManager:class QueueManager(BaseManager): pass # 把两个Queue都注册到网络上, callable参数关联了Queue对象:QueueManager.register(&apos;get_task_queue&apos;, callable=lambda: task_queue)QueueManager.register(&apos;get_result_queue&apos;, callable=lambda: result_queue) # 绑定端口5000, 设置验证码&apos;abc&apos;:manager = QueueManager(address=(&apos;&apos;, 5000), authkey=&apos;abc&apos;) # 启动Queue:manager.start() # 获得通过网络访问的Queue对象:task = manager.get_task_queue()result = manager.get_result_queue() # 放几个任务进去:for i in range(10): n = random.randint(0, 10000) print(&apos;Put task %d...&apos; % n) task.put(n) # 从result队列读取结果:print(&apos;Try get results...&apos;)for i in range(10): r = result.get(timeout=10) print(&apos;Result: %s&apos; % r) # 关闭:manager.shutdown() 请注意，当我们在一台机器上写多进程程序时，创建的Queue可以直接拿来用，但是，在分布式多进程环境下，添加任务到Queue不可以直接对原始的task_queue进行操作，那样就绕过了QueueManager的封装，必须通过manager.get_task_queue()获得的Queue接口添加。 然后，在另一台机器上启动任务进程（本机上启动也可以）： 1234567891011121314151617181920212223242526272829303132333435 # taskworker.pyimport time, sys, Queuefrom multiprocessing.managers import BaseManager # 创建类似的QueueManager:class QueueManager(BaseManager): pass # 由于这个QueueManager只从网络上获取Queue，所以注册时只提供名字:QueueManager.register('get_task_queue')QueueManager.register('get_result_queue') # 连接到服务器，也就是运行taskmanager.py的机器:server_addr = '127.0.0.1'print('Connect to server %s...' % server_addr) # 端口和验证码注意保持与taskmanager.py设置的完全一致:m = QueueManager(address=(server_addr, 5000), authkey='abc') # 从网络连接:m.connect() # 获取Queue的对象:task = m.get_task_queue()result = m.get_result_queue() # 从task队列取任务,并把结果写入result队列:for i in range(10): try: n = task.get(timeout=1) print('run task %d * %d...' % (n, n)) r = '%d * %d = %d' % (n, n, n*n) time.sleep(1) result.put(r) except Queue.Empty: print('task queue is empty.') # 处理结束:print('worker exit.') Queue之所以能通过网络访问，就是通过QueueManager实现的。由于QueueManager管理的不止一个Queue，所以，要给每个Queue的网络调用接口起个名字，比如get_task_queue。 authkey有什么用？这是为了保证两台机器正常通信，不被其他机器恶意干扰。如果taskworker.py的authkey和taskmanager.py的authkey不一致，肯定连接不上。 1234567891011121314151617181920212223242526272829Python的分布式进程接口简单，封装良好，适合需要把繁重任务分布到多台机器的环境下。注意Queue的作用是用来传递任务和接收结果，每个任务的描述数据量要尽量小。比如发送一个处理日志文件的任务，就不要发送几百兆的日志文件本身，而是发送日志文件存放的完整路径，由Worker进程再去共享的磁盘上读取文件。---## 多线程Python的标准库提供了两个模块：thread和threading，```thread```是低级模块，```threading```是高级模块，对thread进行了封装。绝大多数情况下，我们只需要使用threading这个高级模块。启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行：```pythonimport time, threading # 新线程执行的代码:def loop(): print &apos;thread %s is running...&apos; % threading.current_thread().name n = 0 while n &lt; 5: n = n + 1 print &apos;thread %s &gt;&gt;&gt; %s&apos; % (threading.current_thread().name, n) time.sleep(1) print &apos;thread %s ended.&apos; % threading.current_thread().nameprint &apos;thread %s is running...&apos; % threading.current_thread().namet = threading.Thread(target=loop, name=&apos;LoopThread&apos;)t.start()t.join()print &apos;thread %s ended.&apos; % threading.current_thread().name 任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的threading模块有个current_thread()函数，它永远返回当前线程的实例。主线程实例的名字叫MainThread，子线程的名字在创建时指定，我们用LoopThread命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为Thread-1，Thread-2…… Lock 多线程和多进程最大的不同在于，123456789101112131415161718192021222324252627282930313233343536373839- 锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，坏处当然也很多，首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。&gt; 启动与CPU核心数量相同的N个线程，在4核CPU上可以监控到CPU占用率仅有160%，也就是使用不到两核。&gt; 即使启动100个线程，使用率也就170%左右，仍然不到两核。&gt; 但是用C、C++或Java来改写相同的死循环，直接可以把全部核心跑满，4核就跑到400%，8核就跑到800%，为什么Python不行呢？&gt; 因为Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：```Global Interpreter Lock```，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。&gt; GIL是Python解释器设计的历史遗留问题，通常我们用的解释器是官方实现的```CPython```，要真正利用多核，除非重写一个不带GIL的解释器。&gt; 所以，```在Python中，可以使用多线程，但不要指望能有效利用多核。```如果一定要通过多线程利用多核，那只能通过C扩展来实现，不过这样就失去了Python简单易用的特点。&gt; 不过，也不用过于担心，Python虽然不能利用多线程实现多核任务，但```可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响```。---## ThreadLocal- 在多线程环境下，每个线程都有自己的数据。一个线程使用自己的局部变量比使用全局变量好，因为局部变量只有线程自己能看见，不会影响其他线程，而全局变量的修改必须加锁。```pythonimport threading # 创建全局ThreadLocal对象:local_school = threading.local()def process_student(): print &apos;Hello, %s (in %s)&apos; % (local_school.student, threading.current_thread().name)def process_thread(name): # 绑定ThreadLocal的student: local_school.student = name process_student()t1 = threading.Thread(target= process_thread, args=(&apos;Alice&apos;,), name=&apos;Thread-A&apos;)t2 = threading.Thread(target= process_thread, args=(&apos;Bob&apos;,), name=&apos;Thread-B&apos;)t1.start()t2.start()t1.join()t2.join() 全局变量local_school就是一个ThreadLocal对象，每个Thread对它都可以读写student属性，但互不影响。你可以把local_school看成全局变量，但每个属性如local_school.student都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，ThreadLocal内部会处理。 可以理解为全局变量local_school是一个dict，不但可以用local_school.student，还可以绑定其他变量，如local_school.teacher等等。 ThreadLocal最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。","categories":[{"name":"python","slug":"python","permalink":"http://Scofieldsu.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://Scofieldsu.github.io/tags/python/"},{"name":"进程","slug":"进程","permalink":"http://Scofieldsu.github.io/tags/进程/"},{"name":"线程","slug":"线程","permalink":"http://Scofieldsu.github.io/tags/线程/"}]},{"title":"python(1):正则表达式","slug":"python(1):正则表达式","date":"2015-08-08T13:13:45.000Z","updated":"2018-01-14T09:53:31.421Z","comments":true,"path":"2015/08/08/python(1):正则表达式/","link":"","permalink":"http://Scofieldsu.github.io/2015/08/08/python(1):正则表达式/","excerpt":"python(1):正则表达式 1.择一匹配符 | 例如： ab|home|you 匹配：at,home,you 2.匹配任意单个字符 . 例如： f.o 匹配 fao，f9o，f#9等 … 匹配 任意两个字符 注： 匹配除了换行符\\n 以外的任意字符(python正则表达式有一个编译标记[s 或者DOTALL]，该标记能使点号匹配换行符) 匹配句点字符使用\\. 3.字符串起始、结尾、单词边界匹配 起始：^ 或者 \\A (用于没有脱字符^的国际键盘) 结尾：$ 或者\\Z 单词边界匹配：\\b 或者 \\B 例如： \\b 匹配 任何以the开始的字符串 \\bthe\\b 仅仅匹配单词the \\Bthe 热恩和包含但并不以the作为起始的字符串 4.创建字符集 例如： b[aiu]t 匹配 bat、bit、but","text":"python(1):正则表达式 1.择一匹配符 | 例如： ab|home|you 匹配：at,home,you 2.匹配任意单个字符 . 例如： f.o 匹配 fao，f9o，f#9等 … 匹配 任意两个字符 注： 匹配除了换行符\\n 以外的任意字符(python正则表达式有一个编译标记[s 或者DOTALL]，该标记能使点号匹配换行符) 匹配句点字符使用\\. 3.字符串起始、结尾、单词边界匹配 起始：^ 或者 \\A (用于没有脱字符^的国际键盘) 结尾：$ 或者\\Z 单词边界匹配：\\b 或者 \\B 例如： \\b 匹配 任何以the开始的字符串 \\bthe\\b 仅仅匹配单词the \\Bthe 热恩和包含但并不以the作为起始的字符串 4.创建字符集 例如： b[aiu]t 匹配 bat、bit、but 5.限定范围和否定 例如： z.[0-9] 、[r-u][env-y][us]、非元音[aeiou]、不匹配制表符或者\\n[\\t\\n]、 6.使用闭包操作符实现存在性和频数匹配 * + ？ 例如： [dn]ot? 匹配 do、no、dot、not 0？[1-9] 匹配 一系列可能前置0的1～9的数值 [0~9]{15,16} 匹配15或者16个数字 &lt;/?[^&gt;]+&gt; 匹配全部有效的（和无效的）HTML标签 7.字符集的特殊字符 例如： \\d{3,4}-\\d{7} 匹配区号为3或4位的电话号码 \\w+@\\w+.com 匹配xxx@yyy.com 8.使用圆括号指定分组 模式 描述 ^ 匹配字符串的开头 $ 匹配字符串的末尾。 . 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。 […] 用来表示一组字符,单独列出：[amk] 匹配 ‘a’，‘m’或’k’ [^…] 不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。 re* 匹配0个或多个的表达式。 re+ 匹配1个或多个的表达式。 re? 匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式 re{ n} re{ n,} 精确匹配n个前面表达式。 re{ n, m} 匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式 a| b 匹配a或b (re) G匹配括号内的表达式，也表示一个组 (?imx) 正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。 (?-imx) 正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。 (?: re) 类似 (…), 但是不表示一个组 (?imx: re) 在括号中使用i, m, 或 x 可选标志 (?-imx: re) 在括号中不使用i, m, 或 x 可选标志 (?#…) 注释. (?= re) 前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。 (?! re) 前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功 (?&gt; re) 匹配的独立模式，省去回溯。 \\w 匹配字母数字及下划线 \\W 匹配非字母数字及下划线 \\s 匹配任意空白字符，等价于 [\\t\\n\\r\\f]. \\S 匹配任意非空字符 \\d 匹配任意数字，等价于 [0-9]. \\D 匹配任意非数字 \\A 匹配字符串开始 \\Z 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。c \\z 匹配字符串结束 \\G 匹配最后匹配完成的位置。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\\b’ 可以匹配&quot;never&quot; 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \\B 匹配非单词边界。‘er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \\n, \\t, 等. 匹配一个换行符。匹配一个制表符。等 \\1…\\9 匹配第n个分组的子表达式。 \\10 匹配第n个分组的子表达式，如果它经匹配。否则指的是八进制字符码的表达式。","categories":[{"name":"python","slug":"python","permalink":"http://Scofieldsu.github.io/categories/python/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://Scofieldsu.github.io/tags/正则表达式/"}]},{"title":"安装node.js和hexo","slug":"安装node-js和hexo","date":"2015-07-14T17:28:42.000Z","updated":"2018-01-14T17:57:37.881Z","comments":true,"path":"2015/07/15/安装node-js和hexo/","link":"","permalink":"http://Scofieldsu.github.io/2015/07/15/安装node-js和hexo/","excerpt":"安装nodeJS之前，如果没有安装g++及 libssl-dev，则先要安装好，安装方法如下： 12sudo apt-get install g++sudo apt-get install libssl-dev 接下来，就可以下载安装nodeJS了，目前稳定版本为 Node.js 0.6.18，下面是安装步骤： 1234wget http://nodejs.org/dist/v0.8.16/node-v0.8.16.tar.gztar zxvf node-v0.8.16.tar.gz./configuremake &amp;&amp; make install 安装好后，在 控制台下输入： 123node -vv0.8.16即可看到安装好的nodeJS版本号","text":"安装nodeJS之前，如果没有安装g++及 libssl-dev，则先要安装好，安装方法如下： 12sudo apt-get install g++sudo apt-get install libssl-dev 接下来，就可以下载安装nodeJS了，目前稳定版本为 Node.js 0.6.18，下面是安装步骤： 1234wget http://nodejs.org/dist/v0.8.16/node-v0.8.16.tar.gztar zxvf node-v0.8.16.tar.gz./configuremake &amp;&amp; make install 安装好后，在 控制台下输入： 123node -vv0.8.16即可看到安装好的nodeJS版本号 更新版本 node有一个模块叫n，是专门用来管理node.js的版本的。 首先安装n模块： 1npm install -g n 第二步： 升级node.js到最新稳定版 1sudo n stable 安装Hexo Hexo是基于 NodeJS ，所以需要先安装NodeJS。 1npm install -g hexo-cli 初始化框架 12hexo init &lt;yourFolder&gt;cd &lt;yourFolder&gt; 安装依赖 1npm install 初始化完成大概的目录： 1234567891011.├── _config.yml //网站的`配置`信息，您可以在此配置大部分的参数。├── package.json├── db.json // json格式的静态常量数据库├── node_modules // Hexo的功能JavaScript文件├── public // 生成静态网页文件├── scaffolds //模版文件夹。当您新建文章时，Hexo会根据scaffold来建立文件。├── source //资源文件夹是存放用户资源的地方。| ├── _drafts // 草稿文件夹| └── _posts // 文章文件夹└── themes //主题文件夹。Hexo会根据主题来生成静态页面。 新建文章（创建一个Hello World） 1hexo new &lt;title&gt; for example: \"Hello World\" 在/source/_post里添加hello-world.md文件，之后新建的文章都将存放在此目录下。 如果要删除，直接在此文件夹下删除对应的文件即可。 生成网站 1hexo generate 此时会将/source的.md文件生成到/public中，形成网站的静态文件。 服务器 1hexo server -p 3000 输入 http://localhost:3000即可查看网站。 部署网站 1hexo deploy 该操作会将hexo生成的静态内容部署到配置的仓库中，请看下面介绍。 部署网站之前需要生成静态文件，即可以用 $ hexo generate -d 直接生成并部署。 此时需要在 _config.yml 中配置你所要部署的站点： Docs: http://hexo.io/docs/deployment.html deploy: type: git repo: git@github.com:YourRepository.git branch: master 如果没有意外，部署就成功了，可以打开 http://&lt;用户名&gt;.github.io 查看。 常用Hexo命令 清除生成内容 hexo c == hexo clean 执行此操作会删除 public 文件夹中的内容。 hexo g == hexo generate hexo s == hexo server 五、使用Next主题让站点更酷炫 使用NexT Theme 12cd your-hexo-sitegit clone https://github.com/iissnan/hexo-theme-next themes/next 从Next的Gihub仓库中获取最新版本。 Hexo NexT主题的文档结构 1234567891011/languages #用来配置国际化语言版本，里边包含各种个配置像的文本翻译。/layout #以swig文件来定义各种含有配置信息调用的布局/scripts #一些JS脚本/source/css #用来修改自定义样式，需要掌握一定的css语法。/fonts #定义字体文件，可以修改博客字体/images #一些svg图片/js #一些js脚本/vendors/404.html #自定义的公益404页面/test #用于测试 启用NexT主题 需要修改/root/_config.yml配置项theme： Extensions Plugins: http://hexo.io/plugins/ Themes: http://hexo.io/themes/ theme: next 验证是否启用 hexo s --debug","categories":[{"name":"hexo","slug":"hexo","permalink":"http://Scofieldsu.github.io/categories/hexo/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://Scofieldsu.github.io/tags/node-js/"},{"name":"hexo","slug":"hexo","permalink":"http://Scofieldsu.github.io/tags/hexo/"}]},{"title":"ubuntu安装deb包","slug":"ubuntu安装deb包","date":"2015-07-14T17:23:13.000Z","updated":"2018-01-14T09:53:31.437Z","comments":true,"path":"2015/07/15/ubuntu安装deb包/","link":"","permalink":"http://Scofieldsu.github.io/2015/07/15/ubuntu安装deb包/","excerpt":"","text":"安装: sudo dpkg -i ****.deb 解决依赖关系： sudo apt-get -f install 浏览已安装的程序 dpkg --list 卸载程序和所有配置文件 sudo apt-get --pure remove 只卸载程序，保留配置文 sudo apt-get remove","categories":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://Scofieldsu.github.io/categories/ubuntu/"}],"tags":[]},{"title":"win7和ubuntu双系统默认启动","slug":"win7和ubuntu双系统默认启动","date":"2015-07-14T17:21:09.000Z","updated":"2018-01-14T09:53:31.443Z","comments":true,"path":"2015/07/15/win7和ubuntu双系统默认启动/","link":"","permalink":"http://Scofieldsu.github.io/2015/07/15/win7和ubuntu双系统默认启动/","excerpt":"","text":"ubuntu引导开机，则 sudo gedit /etc/default/grub GRUB_DEFAULT=0改为开机时显示的win7的排列数字，例如4 sudo update-grub","categories":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://Scofieldsu.github.io/categories/ubuntu/"}],"tags":[{"name":"双系统启动","slug":"双系统启动","permalink":"http://Scofieldsu.github.io/tags/双系统启动/"}]},{"title":"ubuntu创建快捷方式desktop","slug":"ubuntu创建快捷方式desktop","date":"2015-07-14T17:13:57.000Z","updated":"2018-01-14T09:53:31.440Z","comments":true,"path":"2015/07/15/ubuntu创建快捷方式desktop/","link":"","permalink":"http://Scofieldsu.github.io/2015/07/15/ubuntu创建快捷方式desktop/","excerpt":"","text":"#ubuntu创建快捷方式desktop 例如 把Ulipad添加到系统的“应用程序”菜单里，方法如下： 'sudo gedit /usr/share/applications/Ulipad.desktop’ 然后在里面添加如下内容： [Desktop Entry] Name=Ulipad Comment=a Python IDE Exec=python /home/scofireldyu/下载/ulipad/UliPad.py Icon=/home/scofireldyu/下载/ulipad/ulipad.ico Teminal=false Type=Application Categories=Application;Development;","categories":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://Scofieldsu.github.io/categories/ubuntu/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://Scofieldsu.github.io/tags/ubuntu/"}]},{"title":"鸭子类型","slug":"鸭子类型","date":"2015-04-28T12:19:42.000Z","updated":"2018-01-14T09:53:31.417Z","comments":true,"path":"2015/04/28/鸭子类型/","link":"","permalink":"http://Scofieldsu.github.io/2015/04/28/鸭子类型/","excerpt":"#鸭子类型（duck typing） 在程序设计中，鸭子类型是动态类型的一种风格。 在这种风格中，一个对象有效的语义， 不是由继承自特定的类或实现特定的接口，而是由当前方法和属性的集合决定。 这个概念的名字来源于由James Whitcomb Riley提出的鸭子测试，“鸭子测试”可以这样表述： 当看到一只鸟走起来像鸭子、游泳像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。 在鸭子类型中，关注的不是对象的类型本身，而是它是如何使用的。 例如，在不使用鸭子类型的语言中，我们可以编写一个函数，它接受一个类型为鸭子的对象，并调用它的走和叫的方法。在使用鸭子类型的语言中，这样的一个函数可以接受一个任意类型的对象，并调用它的走和叫方法。如果这些需要被调用的方法不存在，那么将会引发一个运行时错误。任何拥有这样的正确的走和叫方法的对象都可被函数接受的这种行为引出了以上表述，这种决定类型的方式因此得名。","text":"#鸭子类型（duck typing） 在程序设计中，鸭子类型是动态类型的一种风格。 在这种风格中，一个对象有效的语义， 不是由继承自特定的类或实现特定的接口，而是由当前方法和属性的集合决定。 这个概念的名字来源于由James Whitcomb Riley提出的鸭子测试，“鸭子测试”可以这样表述： 当看到一只鸟走起来像鸭子、游泳像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。 在鸭子类型中，关注的不是对象的类型本身，而是它是如何使用的。 例如，在不使用鸭子类型的语言中，我们可以编写一个函数，它接受一个类型为鸭子的对象，并调用它的走和叫的方法。在使用鸭子类型的语言中，这样的一个函数可以接受一个任意类型的对象，并调用它的走和叫方法。如果这些需要被调用的方法不存在，那么将会引发一个运行时错误。任何拥有这样的正确的走和叫方法的对象都可被函数接受的这种行为引出了以上表述，这种决定类型的方式因此得名。 鸭子类型通常得益于不测试方法和函数中参数的类型，而是依赖文档、清晰的代码和测试来确保正确使用。 从静态类型语言转向动态类型语言的用户通常试图添加一些静态的（在运行之前的）类型检查，从而影响了鸭子类型的益处和可伸缩性，并约束了语言的动态特性（Python文档中有一句：鸭子类型应避免使用type()或instance()等方法来测试类型是否合法） 看下面一段代码： ’ I love you class Duck: def quack(self): print(‘呱呱呱！’) def feathers(self): print(‘这个鸭子拥有灰白的羽毛’) class Person: def quack(self): print(‘我不是鸭子’) def feathers(self): print(‘这个人穿着一件鸭绒大衣’) def in_the_forest(duck): duck.quack() duck.feathers() def game(): donald = Duck() john = Person() in_the_forest(donald) in_the_forest(john) game() ’ #返回： #呱呱呱！ #这个鸭子拥有灰白的羽毛 #我不是鸭子 #这个人穿着一件鸭绒大衣 从哪里可以看出Python是鸭子类型的风格呢？ in_the_forest()函数对参数duck只有一个要求：就是可以实现quack()和feathers()方法。然而Duck类和Person类都实现了quack()和feathers()方法，因此它们的实例对象donald和john都可以用作in_the_forest()的参数。这就是鸭子类型。 如果不是鸭子类型的做法 def in_the_forest(animal): animal.quack() animal.feathers() class animal: def quack(): pass def feathers(): pass class Duck(animal): def quack(self): print(‘呱呱呱！’) def feathers(self): print(‘这个鸭子拥有灰白的羽毛’) class Person(animal): def quack(self): print(‘我不是鸭子’) def feathers(self): print(‘这个人穿着一件鸭绒大衣’) def game(): donald = Duck() john = Person() in_the_forest(donald) in_the_forest(john) game()","categories":[{"name":"python","slug":"python","permalink":"http://Scofieldsu.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://Scofieldsu.github.io/tags/python/"}]}]}